//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IConversationClient {

    startConversations(selectedServices: SelectedServices): Promise<string>;

    enqueueConversation(command: StartConversationCommand): Promise<string>;
}

export class ConversationClient implements IConversationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    startConversations(selectedServices: SelectedServices): Promise<string> {
        let url_ = this.baseUrl + "/api/Conversation/StartConversations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedServices);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartConversations(_response);
        });
    }

    protected processStartConversations(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    enqueueConversation(command: StartConversationCommand): Promise<string> {
        let url_ = this.baseUrl + "/api/Conversation/EnqueueConversation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnqueueConversation(_response);
        });
    }

    protected processEnqueueConversation(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IGarageAccountClient {

    getSettings(): Promise<GarageItemDto>;

    getOverview(): Promise<GarageOverview>;

    getServices(): Promise<GarageServiceItemDto[]>;

    getEmployees(): Promise<GarageEmployeeItemDto[]>;

    create(command: CreateGarageCommand): Promise<GarageItem>;

    createService(command: CreateGarageServiceCommand): Promise<GarageServiceItem>;

    createEmployee(command: CreateGarageEmployeeCommand): Promise<GarageEmployeeItem>;

    updateSettings(command: UpdateGarageSettingsCommand): Promise<GarageItem>;

    updateService(command: UpdateGarageServiceCommand): Promise<GarageServiceItem>;

    updateEmployee(command: UpdateGarageEmployeeCommand): Promise<GarageEmployeeItem>;

    deleteService(id: string): Promise<GarageServiceItem>;

    deleteEmployee(id: string): Promise<GarageEmployeeItem>;
}

export class GarageAccountClient implements IGarageAccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSettings(): Promise<GarageItemDto> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<GarageItemDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageItemDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageItemDto>(null as any);
    }

    getOverview(): Promise<GarageOverview> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetOverview";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOverview(_response);
        });
    }

    protected processGetOverview(response: Response): Promise<GarageOverview> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageOverview.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageOverview>(null as any);
    }

    getServices(): Promise<GarageServiceItemDto[]> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetServices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServices(_response);
        });
    }

    protected processGetServices(response: Response): Promise<GarageServiceItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageServiceItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceItemDto[]>(null as any);
    }

    getEmployees(): Promise<GarageEmployeeItemDto[]> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetEmployees";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployees(_response);
        });
    }

    protected processGetEmployees(response: Response): Promise<GarageEmployeeItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageEmployeeItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageEmployeeItemDto[]>(null as any);
    }

    create(command: CreateGarageCommand): Promise<GarageItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<GarageItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageItem>(null as any);
    }

    createService(command: CreateGarageServiceCommand): Promise<GarageServiceItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/CreateService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateService(_response);
        });
    }

    protected processCreateService(response: Response): Promise<GarageServiceItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageServiceItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceItem>(null as any);
    }

    createEmployee(command: CreateGarageEmployeeCommand): Promise<GarageEmployeeItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/CreateEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEmployee(_response);
        });
    }

    protected processCreateEmployee(response: Response): Promise<GarageEmployeeItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageEmployeeItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageEmployeeItem>(null as any);
    }

    updateSettings(command: UpdateGarageSettingsCommand): Promise<GarageItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/UpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSettings(_response);
        });
    }

    protected processUpdateSettings(response: Response): Promise<GarageItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageItem>(null as any);
    }

    updateService(command: UpdateGarageServiceCommand): Promise<GarageServiceItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/UpdateService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateService(_response);
        });
    }

    protected processUpdateService(response: Response): Promise<GarageServiceItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageServiceItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceItem>(null as any);
    }

    updateEmployee(command: UpdateGarageEmployeeCommand): Promise<GarageEmployeeItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/UpdateEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEmployee(_response);
        });
    }

    protected processUpdateEmployee(response: Response): Promise<GarageEmployeeItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageEmployeeItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageEmployeeItem>(null as any);
    }

    deleteService(id: string): Promise<GarageServiceItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/DeleteService/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteService(_response);
        });
    }

    protected processDeleteService(response: Response): Promise<GarageServiceItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageServiceItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceItem>(null as any);
    }

    deleteEmployee(id: string): Promise<GarageEmployeeItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/DeleteEmployee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEmployee(_response);
        });
    }

    protected processDeleteEmployee(response: Response): Promise<GarageEmployeeItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageEmployeeItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageEmployeeItem>(null as any);
    }
}

export interface IGarageClient {

    getServiceTypes(licensePlate: string | null): Promise<GarageServiceType[]>;

    searchLookups(licensePlate: string | null, latitude: number, longitude: number, inMetersRange: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, autoCompleteOnGarageName: string | null | undefined, filters: string[] | null | undefined): Promise<PaginatedListOfGarageLookupBriefDto>;

    searchLookupsByName(name: string | null | undefined, maxSize: number | undefined): Promise<GarageLookupSimplefiedDto[]>;

    getLookup(identifier: string | null, licensePlate: string | null | undefined): Promise<GarageLookupDto>;

    getLookupsStatus(): Promise<GarageLookupsStatusDto>;

    /**
     * @param maxInsertAmount (optional) -1 is all of them
     * @param maxUpdateAmount (optional) -1 is all of them
     */
    upsertLookups(maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined): Promise<string>;
}

export class GarageClient implements IGarageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getServiceTypes(licensePlate: string | null): Promise<GarageServiceType[]> {
        let url_ = this.baseUrl + "/api/Garage/GetServiceTypes/{licensePlate}";
        if (licensePlate === undefined || licensePlate === null)
            throw new Error("The parameter 'licensePlate' must be defined.");
        url_ = url_.replace("{licensePlate}", encodeURIComponent("" + licensePlate));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceTypes(_response);
        });
    }

    protected processGetServiceTypes(response: Response): Promise<GarageServiceType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceType[]>(null as any);
    }

    searchLookups(licensePlate: string | null, latitude: number, longitude: number, inMetersRange: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, autoCompleteOnGarageName: string | null | undefined, filters: string[] | null | undefined): Promise<PaginatedListOfGarageLookupBriefDto> {
        let url_ = this.baseUrl + "/api/Garage/SearchLookups/{licensePlate}/{latitude}/{longitude}?";
        if (licensePlate === undefined || licensePlate === null)
            throw new Error("The parameter 'licensePlate' must be defined.");
        url_ = url_.replace("{licensePlate}", encodeURIComponent("" + licensePlate));
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined.");
        url_ = url_.replace("{latitude}", encodeURIComponent("" + latitude));
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined.");
        url_ = url_.replace("{longitude}", encodeURIComponent("" + longitude));
        if (inMetersRange === null)
            throw new Error("The parameter 'inMetersRange' cannot be null.");
        else if (inMetersRange !== undefined)
            url_ += "inMetersRange=" + encodeURIComponent("" + inMetersRange) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (autoCompleteOnGarageName !== undefined && autoCompleteOnGarageName !== null)
            url_ += "autoCompleteOnGarageName=" + encodeURIComponent("" + autoCompleteOnGarageName) + "&";
        if (filters !== undefined && filters !== null)
            filters && filters.forEach(item => { url_ += "filters=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchLookups(_response);
        });
    }

    protected processSearchLookups(response: Response): Promise<PaginatedListOfGarageLookupBriefDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfGarageLookupBriefDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfGarageLookupBriefDto>(null as any);
    }

    searchLookupsByName(name: string | null | undefined, maxSize: number | undefined): Promise<GarageLookupSimplefiedDto[]> {
        let url_ = this.baseUrl + "/api/Garage/SearchLookupsByName?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (maxSize === null)
            throw new Error("The parameter 'maxSize' cannot be null.");
        else if (maxSize !== undefined)
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchLookupsByName(_response);
        });
    }

    protected processSearchLookupsByName(response: Response): Promise<GarageLookupSimplefiedDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageLookupSimplefiedDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageLookupSimplefiedDto[]>(null as any);
    }

    getLookup(identifier: string | null, licensePlate: string | null | undefined): Promise<GarageLookupDto> {
        let url_ = this.baseUrl + "/api/Garage/GetLookup/{identifier}?";
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier));
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLookup(_response);
        });
    }

    protected processGetLookup(response: Response): Promise<GarageLookupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageLookupDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageLookupDto>(null as any);
    }

    getLookupsStatus(): Promise<GarageLookupsStatusDto> {
        let url_ = this.baseUrl + "/api/Garage/GetLookupsStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLookupsStatus(_response);
        });
    }

    protected processGetLookupsStatus(response: Response): Promise<GarageLookupsStatusDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageLookupsStatusDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageLookupsStatusDto>(null as any);
    }

    /**
     * @param maxInsertAmount (optional) -1 is all of them
     * @param maxUpdateAmount (optional) -1 is all of them
     */
    upsertLookups(maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Garage/UpsertLookups?";
        if (maxInsertAmount === null)
            throw new Error("The parameter 'maxInsertAmount' cannot be null.");
        else if (maxInsertAmount !== undefined)
            url_ += "maxInsertAmount=" + encodeURIComponent("" + maxInsertAmount) + "&";
        if (maxUpdateAmount === null)
            throw new Error("The parameter 'maxUpdateAmount' cannot be null.");
        else if (maxUpdateAmount !== undefined)
            url_ += "maxUpdateAmount=" + encodeURIComponent("" + maxUpdateAmount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsertLookups(_response);
        });
    }

    protected processUpsertLookups(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IVehicleClient {

    getSpecificationsCard(licensePlate: string | null | undefined): Promise<VehicleSpecificationsCardItem>;

    getSpecifications(licensePlate: string | null | undefined): Promise<VehicleSpecificationsDtoItem>;

    getServiceLogs(licensePlate: string | null | undefined): Promise<VehicleServiceLogDtoItem[]>;

    /**
     * @param licensePlate (optional) 
     * @param maxAmount (optional) -1 means all of them
     */
    getTimeline(licensePlate: string | null | undefined, maxAmount: number | undefined): Promise<VehicleTimelineDtoItem[]>;

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    upsertLookups(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string>;

    upsertTimeline(licensePlate: string | null | undefined): Promise<string>;

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    upsertTimelines(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string>;

    createServiceLog(serviceLogCommand_VehicleLicensePlate: string | null | undefined, serviceLogCommand_GarageLookupIdentifier: string | null | undefined, serviceLogCommand_Type: GarageServiceType | undefined, serviceLogCommand_Description: string | null | undefined, serviceLogCommand_Date: string | null | undefined, serviceLogCommand_ExpectedNextDate: string | null | undefined, serviceLogCommand_OdometerReading: number | undefined, serviceLogCommand_ExpectedNextOdometerReading: number | null | undefined, serviceLogCommand_ReporterName: string | null | undefined, serviceLogCommand_ReporterPhoneNumber: string | null | undefined, serviceLogCommand_ReporterEmailAddress: string | null | undefined, serviceLogCommand_Attachment_FileName: string | null | undefined, serviceLogCommand_Attachment_FileData: string | null | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogDtoItem>;

    deleteServiceLog(serviceLogId: string): Promise<VehicleServiceLogDtoItem>;
}

export class VehicleClient implements IVehicleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSpecificationsCard(licensePlate: string | null | undefined): Promise<VehicleSpecificationsCardItem> {
        let url_ = this.baseUrl + "/api/Vehicle/GetSpecificationsCard?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpecificationsCard(_response);
        });
    }

    protected processGetSpecificationsCard(response: Response): Promise<VehicleSpecificationsCardItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleSpecificationsCardItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleSpecificationsCardItem>(null as any);
    }

    getSpecifications(licensePlate: string | null | undefined): Promise<VehicleSpecificationsDtoItem> {
        let url_ = this.baseUrl + "/api/Vehicle/GetSpecifications?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpecifications(_response);
        });
    }

    protected processGetSpecifications(response: Response): Promise<VehicleSpecificationsDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleSpecificationsDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleSpecificationsDtoItem>(null as any);
    }

    getServiceLogs(licensePlate: string | null | undefined): Promise<VehicleServiceLogDtoItem[]> {
        let url_ = this.baseUrl + "/api/Vehicle/GetServiceLogs?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceLogs(_response);
        });
    }

    protected processGetServiceLogs(response: Response): Promise<VehicleServiceLogDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleServiceLogDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogDtoItem[]>(null as any);
    }

    /**
     * @param licensePlate (optional) 
     * @param maxAmount (optional) -1 means all of them
     */
    getTimeline(licensePlate: string | null | undefined, maxAmount: number | undefined): Promise<VehicleTimelineDtoItem[]> {
        let url_ = this.baseUrl + "/api/Vehicle/GetTimeline?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        if (maxAmount === null)
            throw new Error("The parameter 'maxAmount' cannot be null.");
        else if (maxAmount !== undefined)
            url_ += "maxAmount=" + encodeURIComponent("" + maxAmount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeline(_response);
        });
    }

    protected processGetTimeline(response: Response): Promise<VehicleTimelineDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleTimelineDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleTimelineDtoItem[]>(null as any);
    }

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    upsertLookups(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Vehicle/UpsertLookups?";
        if (startRowIndex === null)
            throw new Error("The parameter 'startRowIndex' cannot be null.");
        else if (startRowIndex !== undefined)
            url_ += "startRowIndex=" + encodeURIComponent("" + startRowIndex) + "&";
        if (endRowIndex === null)
            throw new Error("The parameter 'endRowIndex' cannot be null.");
        else if (endRowIndex !== undefined)
            url_ += "endRowIndex=" + encodeURIComponent("" + endRowIndex) + "&";
        if (maxInsertAmount === null)
            throw new Error("The parameter 'maxInsertAmount' cannot be null.");
        else if (maxInsertAmount !== undefined)
            url_ += "maxInsertAmount=" + encodeURIComponent("" + maxInsertAmount) + "&";
        if (maxUpdateAmount === null)
            throw new Error("The parameter 'maxUpdateAmount' cannot be null.");
        else if (maxUpdateAmount !== undefined)
            url_ += "maxUpdateAmount=" + encodeURIComponent("" + maxUpdateAmount) + "&";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsertLookups(_response);
        });
    }

    protected processUpsertLookups(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    upsertTimeline(licensePlate: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Vehicle/UpsertTimeline?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsertTimeline(_response);
        });
    }

    protected processUpsertTimeline(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    upsertTimelines(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Vehicle/UpsertTimelines?";
        if (startRowIndex === null)
            throw new Error("The parameter 'startRowIndex' cannot be null.");
        else if (startRowIndex !== undefined)
            url_ += "startRowIndex=" + encodeURIComponent("" + startRowIndex) + "&";
        if (endRowIndex === null)
            throw new Error("The parameter 'endRowIndex' cannot be null.");
        else if (endRowIndex !== undefined)
            url_ += "endRowIndex=" + encodeURIComponent("" + endRowIndex) + "&";
        if (maxInsertAmount === null)
            throw new Error("The parameter 'maxInsertAmount' cannot be null.");
        else if (maxInsertAmount !== undefined)
            url_ += "maxInsertAmount=" + encodeURIComponent("" + maxInsertAmount) + "&";
        if (maxUpdateAmount === null)
            throw new Error("The parameter 'maxUpdateAmount' cannot be null.");
        else if (maxUpdateAmount !== undefined)
            url_ += "maxUpdateAmount=" + encodeURIComponent("" + maxUpdateAmount) + "&";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsertTimelines(_response);
        });
    }

    protected processUpsertTimelines(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    createServiceLog(serviceLogCommand_VehicleLicensePlate: string | null | undefined, serviceLogCommand_GarageLookupIdentifier: string | null | undefined, serviceLogCommand_Type: GarageServiceType | undefined, serviceLogCommand_Description: string | null | undefined, serviceLogCommand_Date: string | null | undefined, serviceLogCommand_ExpectedNextDate: string | null | undefined, serviceLogCommand_OdometerReading: number | undefined, serviceLogCommand_ExpectedNextOdometerReading: number | null | undefined, serviceLogCommand_ReporterName: string | null | undefined, serviceLogCommand_ReporterPhoneNumber: string | null | undefined, serviceLogCommand_ReporterEmailAddress: string | null | undefined, serviceLogCommand_Attachment_FileName: string | null | undefined, serviceLogCommand_Attachment_FileData: string | null | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogDtoItem> {
        let url_ = this.baseUrl + "/api/Vehicle/CreateServiceLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (serviceLogCommand_VehicleLicensePlate !== null && serviceLogCommand_VehicleLicensePlate !== undefined)
            content_.append("ServiceLogCommand.VehicleLicensePlate", serviceLogCommand_VehicleLicensePlate.toString());
        if (serviceLogCommand_GarageLookupIdentifier !== null && serviceLogCommand_GarageLookupIdentifier !== undefined)
            content_.append("ServiceLogCommand.GarageLookupIdentifier", serviceLogCommand_GarageLookupIdentifier.toString());
        if (serviceLogCommand_Type === null || serviceLogCommand_Type === undefined)
            throw new Error("The parameter 'serviceLogCommand_Type' cannot be null.");
        else
            content_.append("ServiceLogCommand.Type", serviceLogCommand_Type.toString());
        if (serviceLogCommand_Description !== null && serviceLogCommand_Description !== undefined)
            content_.append("ServiceLogCommand.Description", serviceLogCommand_Description.toString());
        if (serviceLogCommand_Date !== null && serviceLogCommand_Date !== undefined)
            content_.append("ServiceLogCommand.Date", serviceLogCommand_Date.toString());
        if (serviceLogCommand_ExpectedNextDate !== null && serviceLogCommand_ExpectedNextDate !== undefined)
            content_.append("ServiceLogCommand.ExpectedNextDate", serviceLogCommand_ExpectedNextDate.toString());
        if (serviceLogCommand_OdometerReading === null || serviceLogCommand_OdometerReading === undefined)
            throw new Error("The parameter 'serviceLogCommand_OdometerReading' cannot be null.");
        else
            content_.append("ServiceLogCommand.OdometerReading", serviceLogCommand_OdometerReading.toString());
        if (serviceLogCommand_ExpectedNextOdometerReading !== null && serviceLogCommand_ExpectedNextOdometerReading !== undefined)
            content_.append("ServiceLogCommand.ExpectedNextOdometerReading", serviceLogCommand_ExpectedNextOdometerReading.toString());
        if (serviceLogCommand_ReporterName !== null && serviceLogCommand_ReporterName !== undefined)
            content_.append("ServiceLogCommand.ReporterName", serviceLogCommand_ReporterName.toString());
        if (serviceLogCommand_ReporterPhoneNumber !== null && serviceLogCommand_ReporterPhoneNumber !== undefined)
            content_.append("ServiceLogCommand.ReporterPhoneNumber", serviceLogCommand_ReporterPhoneNumber.toString());
        if (serviceLogCommand_ReporterEmailAddress !== null && serviceLogCommand_ReporterEmailAddress !== undefined)
            content_.append("ServiceLogCommand.ReporterEmailAddress", serviceLogCommand_ReporterEmailAddress.toString());
        if (serviceLogCommand_Attachment_FileName !== null && serviceLogCommand_Attachment_FileName !== undefined)
            content_.append("ServiceLogCommand.Attachment.FileName", serviceLogCommand_Attachment_FileName.toString());
        if (serviceLogCommand_Attachment_FileData !== null && serviceLogCommand_Attachment_FileData !== undefined)
            content_.append("ServiceLogCommand.Attachment.FileData", serviceLogCommand_Attachment_FileData.toString());
        if (attachmentFile !== null && attachmentFile !== undefined)
            content_.append("AttachmentFile", attachmentFile.data, attachmentFile.fileName ? attachmentFile.fileName : "AttachmentFile");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServiceLog(_response);
        });
    }

    protected processCreateServiceLog(response: Response): Promise<VehicleServiceLogDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleServiceLogDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogDtoItem>(null as any);
    }

    deleteServiceLog(serviceLogId: string): Promise<VehicleServiceLogDtoItem> {
        let url_ = this.baseUrl + "/api/Vehicle/DeleteServiceLog/{serviceLogId}";
        if (serviceLogId === undefined || serviceLogId === null)
            throw new Error("The parameter 'serviceLogId' must be defined.");
        url_ = url_.replace("{serviceLogId}", encodeURIComponent("" + serviceLogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServiceLog(_response);
        });
    }

    protected processDeleteServiceLog(response: Response): Promise<VehicleServiceLogDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleServiceLogDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogDtoItem>(null as any);
    }
}

export interface IWebhookClient {

    configureWhatsAppMessageWebhook(hubMode: string | null | undefined, hubChallenge: number | undefined, hubVerifyToken: string | null | undefined): Promise<string>;

    receiveWhatsAppTextMessage(messageReceived: any): Promise<FileResponse>;
}

export class WebhookClient implements IWebhookClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    configureWhatsAppMessageWebhook(hubMode: string | null | undefined, hubChallenge: number | undefined, hubVerifyToken: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Webhook/ConfigureWhatsAppMessageWebhook?";
        if (hubMode !== undefined && hubMode !== null)
            url_ += "hub.mode=" + encodeURIComponent("" + hubMode) + "&";
        if (hubChallenge === null)
            throw new Error("The parameter 'hubChallenge' cannot be null.");
        else if (hubChallenge !== undefined)
            url_ += "hub.challenge=" + encodeURIComponent("" + hubChallenge) + "&";
        if (hubVerifyToken !== undefined && hubVerifyToken !== null)
            url_ += "hub.verify_token=" + encodeURIComponent("" + hubVerifyToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigureWhatsAppMessageWebhook(_response);
        });
    }

    protected processConfigureWhatsAppMessageWebhook(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    receiveWhatsAppTextMessage(messageReceived: any): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Webhook/ReceiveWhatsAppTextMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(messageReceived);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReceiveWhatsAppTextMessage(_response);
        });
    }

    protected processReceiveWhatsAppTextMessage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class BadRequestResponse implements IBadRequestResponse {
    type?: string;
    title?: string;
    status?: number;
    errors?: { [key: string]: string; };

    constructor(data?: IBadRequestResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
        }
    }

    static fromJS(data: any): BadRequestResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BadRequestResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IBadRequestResponse {
    type?: string;
    title?: string;
    status?: number;
    errors?: { [key: string]: string; };
}

export class SelectedServices implements ISelectedServices {
    senderPhoneNumber?: string | undefined;
    senderWhatsappNumber?: string | undefined;
    senderEmailAddress?: string | undefined;
    messageType?: ConversationType;
    messageContent?: string;
    services?: SelectedService[];

    constructor(data?: ISelectedServices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderPhoneNumber = _data["senderPhoneNumber"];
            this.senderWhatsappNumber = _data["senderWhatsappNumber"];
            this.senderEmailAddress = _data["senderEmailAddress"];
            this.messageType = _data["messageType"];
            this.messageContent = _data["messageContent"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(SelectedService.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectedServices {
        data = typeof data === 'object' ? data : {};
        let result = new SelectedServices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderPhoneNumber"] = this.senderPhoneNumber;
        data["senderWhatsappNumber"] = this.senderWhatsappNumber;
        data["senderEmailAddress"] = this.senderEmailAddress;
        data["messageType"] = this.messageType;
        data["messageContent"] = this.messageContent;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectedServices {
    senderPhoneNumber?: string | undefined;
    senderWhatsappNumber?: string | undefined;
    senderEmailAddress?: string | undefined;
    messageType?: ConversationType;
    messageContent?: string;
    services?: SelectedService[];
}

export enum ConversationType {
    Other = 0,
    Price = 1,
    Appointment = 2,
    Technical = 3,
    RequestAQuote = 4,
}

export class SelectedService implements ISelectedService {
    relatedGarageLookupIdentifier?: string;
    relatedGarageLookupName?: string;
    relatedServiceType?: GarageServiceType;
    relatedServiceTypeTitle?: string;
    vehicleLicensePlate?: string;
    vehicleLongitude?: string;
    vehicleLatitude?: string;
    garageContactIdentifier?: string | undefined;
    garageContactType?: ContactType | undefined;

    constructor(data?: ISelectedService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relatedGarageLookupIdentifier = _data["relatedGarageLookupIdentifier"];
            this.relatedGarageLookupName = _data["relatedGarageLookupName"];
            this.relatedServiceType = _data["relatedServiceType"];
            this.relatedServiceTypeTitle = _data["relatedServiceTypeTitle"];
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.vehicleLongitude = _data["vehicleLongitude"];
            this.vehicleLatitude = _data["vehicleLatitude"];
            this.garageContactIdentifier = _data["garageContactIdentifier"];
            this.garageContactType = _data["garageContactType"];
        }
    }

    static fromJS(data: any): SelectedService {
        data = typeof data === 'object' ? data : {};
        let result = new SelectedService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedGarageLookupIdentifier"] = this.relatedGarageLookupIdentifier;
        data["relatedGarageLookupName"] = this.relatedGarageLookupName;
        data["relatedServiceType"] = this.relatedServiceType;
        data["relatedServiceTypeTitle"] = this.relatedServiceTypeTitle;
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["vehicleLongitude"] = this.vehicleLongitude;
        data["vehicleLatitude"] = this.vehicleLatitude;
        data["garageContactIdentifier"] = this.garageContactIdentifier;
        data["garageContactType"] = this.garageContactType;
        return data;
    }
}

export interface ISelectedService {
    relatedGarageLookupIdentifier?: string;
    relatedGarageLookupName?: string;
    relatedServiceType?: GarageServiceType;
    relatedServiceTypeTitle?: string;
    vehicleLicensePlate?: string;
    vehicleLongitude?: string;
    vehicleLatitude?: string;
    garageContactIdentifier?: string | undefined;
    garageContactType?: ContactType | undefined;
}

export enum GarageServiceType {
    Other = 0,
    CompanyStockService = 30,
    RegistrationService = 40,
    AcceleratedRegistrationService = 50,
    MOTServiceLightVehicle = 60,
    MOTServiceHeavyVehicle = 61,
    MOTServiceAgriculture = 62,
    ControlDeviceService = 70,
    GasInstallationService = 80,
    MopedConversionService = 90,
    DismantlingService = 100,
    TaxiComputerService = 110,
    LicensePlateManufactureService = 120,
    Service = 129,
    Repair = 130,
    Inspection = 131,
    SmallMaintenance = 132,
    GreatMaintenance = 133,
    AirConditioningMaintenance = 134,
    SeasonalTireChange = 135,
}

export enum ContactType {
    Email = 0,
    WhatsApp = 1,
    PhoneNumber = 2,
}

export class StartConversationCommand implements IStartConversationCommand {
    relatedGarageLookupIdentifier?: string;
    relatedGarage?: GarageLookupItem;
    relatedVehicleLicensePlate?: string;
    relatedVehicle?: VehicleLookupItem;
    relatedServiceTypes?: GarageServiceType[];
    senderWhatsAppNumberOrEmail?: string;
    senderContactType?: ContactType;
    receiverWhatsAppNumberOrEmail?: string;
    receiverContactType?: ContactType;
    conversationType?: ConversationType;
    messageContent?: string;
    queueingService?: IQueueService;

    constructor(data?: IStartConversationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relatedGarageLookupIdentifier = _data["relatedGarageLookupIdentifier"];
            this.relatedGarage = _data["relatedGarage"] ? GarageLookupItem.fromJS(_data["relatedGarage"]) : <any>undefined;
            this.relatedVehicleLicensePlate = _data["relatedVehicleLicensePlate"];
            this.relatedVehicle = _data["relatedVehicle"] ? VehicleLookupItem.fromJS(_data["relatedVehicle"]) : <any>undefined;
            if (Array.isArray(_data["relatedServiceTypes"])) {
                this.relatedServiceTypes = [] as any;
                for (let item of _data["relatedServiceTypes"])
                    this.relatedServiceTypes!.push(item);
            }
            this.senderWhatsAppNumberOrEmail = _data["senderWhatsAppNumberOrEmail"];
            this.senderContactType = _data["senderContactType"];
            this.receiverWhatsAppNumberOrEmail = _data["receiverWhatsAppNumberOrEmail"];
            this.receiverContactType = _data["receiverContactType"];
            this.conversationType = _data["conversationType"];
            this.messageContent = _data["messageContent"];
            this.queueingService = _data["queueingService"] ? IQueueService.fromJS(_data["queueingService"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StartConversationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StartConversationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedGarageLookupIdentifier"] = this.relatedGarageLookupIdentifier;
        data["relatedGarage"] = this.relatedGarage ? this.relatedGarage.toJSON() : <any>undefined;
        data["relatedVehicleLicensePlate"] = this.relatedVehicleLicensePlate;
        data["relatedVehicle"] = this.relatedVehicle ? this.relatedVehicle.toJSON() : <any>undefined;
        if (Array.isArray(this.relatedServiceTypes)) {
            data["relatedServiceTypes"] = [];
            for (let item of this.relatedServiceTypes)
                data["relatedServiceTypes"].push(item);
        }
        data["senderWhatsAppNumberOrEmail"] = this.senderWhatsAppNumberOrEmail;
        data["senderContactType"] = this.senderContactType;
        data["receiverWhatsAppNumberOrEmail"] = this.receiverWhatsAppNumberOrEmail;
        data["receiverContactType"] = this.receiverContactType;
        data["conversationType"] = this.conversationType;
        data["messageContent"] = this.messageContent;
        data["queueingService"] = this.queueingService ? this.queueingService.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStartConversationCommand {
    relatedGarageLookupIdentifier?: string;
    relatedGarage?: GarageLookupItem;
    relatedVehicleLicensePlate?: string;
    relatedVehicle?: VehicleLookupItem;
    relatedServiceTypes?: GarageServiceType[];
    senderWhatsAppNumberOrEmail?: string;
    senderContactType?: ContactType;
    receiverWhatsAppNumberOrEmail?: string;
    receiverContactType?: ContactType;
    conversationType?: ConversationType;
    messageContent?: string;
    queueingService?: IQueueService;
}

export class GarageLookupItem implements IGarageLookupItem {
    identifier!: string;
    garageId?: string | undefined;
    name!: string;
    knownServices?: GarageServiceType[];
    knownServicesString!: string;
    address!: string;
    city!: string;
    location!: Geometry;
    image?: string | undefined;
    imageThumbnail?: string | undefined;
    status?: string | undefined;
    daysOfWeek?: number[] | undefined;
    daysOfWeekString?: string;
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    conversationContactIdentifier?: string | undefined;
    conversationContactType?: ContactType | undefined;
    website?: string | undefined;
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    hasPickupService?: boolean;
    hasReplacementTransportService?: boolean;
    created!: Date;
    createdBy?: string | undefined;
    lastModified!: Date;
    lastModifiedBy?: string | undefined;
    conversations!: ConversationItem[];
    largeData?: GarageLookupLargeItem | undefined;

    constructor(data?: IGarageLookupItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.conversations = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
            this.garageId = _data["garageId"];
            this.name = _data["name"];
            if (Array.isArray(_data["knownServices"])) {
                this.knownServices = [] as any;
                for (let item of _data["knownServices"])
                    this.knownServices!.push(item);
            }
            this.knownServicesString = _data["knownServicesString"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.location = _data["location"] ? Geometry.fromJS(_data["location"]) : <any>undefined;
            this.image = _data["image"];
            this.imageThumbnail = _data["imageThumbnail"];
            this.status = _data["status"];
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(item);
            }
            this.daysOfWeekString = _data["daysOfWeekString"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsappNumber = _data["whatsappNumber"];
            this.emailAddress = _data["emailAddress"];
            this.conversationContactIdentifier = _data["conversationContactIdentifier"];
            this.conversationContactType = _data["conversationContactType"];
            this.website = _data["website"];
            this.rating = _data["rating"];
            this.userRatingsTotal = _data["userRatingsTotal"];
            this.hasPickupService = _data["hasPickupService"];
            this.hasReplacementTransportService = _data["hasReplacementTransportService"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            if (Array.isArray(_data["conversations"])) {
                this.conversations = [] as any;
                for (let item of _data["conversations"])
                    this.conversations!.push(ConversationItem.fromJS(item));
            }
            this.largeData = _data["largeData"] ? GarageLookupLargeItem.fromJS(_data["largeData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GarageLookupItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["garageId"] = this.garageId;
        data["name"] = this.name;
        if (Array.isArray(this.knownServices)) {
            data["knownServices"] = [];
            for (let item of this.knownServices)
                data["knownServices"].push(item);
        }
        data["knownServicesString"] = this.knownServicesString;
        data["address"] = this.address;
        data["city"] = this.city;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        data["status"] = this.status;
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item);
        }
        data["daysOfWeekString"] = this.daysOfWeekString;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsappNumber"] = this.whatsappNumber;
        data["emailAddress"] = this.emailAddress;
        data["conversationContactIdentifier"] = this.conversationContactIdentifier;
        data["conversationContactType"] = this.conversationContactType;
        data["website"] = this.website;
        data["rating"] = this.rating;
        data["userRatingsTotal"] = this.userRatingsTotal;
        data["hasPickupService"] = this.hasPickupService;
        data["hasReplacementTransportService"] = this.hasReplacementTransportService;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        if (Array.isArray(this.conversations)) {
            data["conversations"] = [];
            for (let item of this.conversations)
                data["conversations"].push(item.toJSON());
        }
        data["largeData"] = this.largeData ? this.largeData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGarageLookupItem {
    identifier: string;
    garageId?: string | undefined;
    name: string;
    knownServices?: GarageServiceType[];
    knownServicesString: string;
    address: string;
    city: string;
    location: Geometry;
    image?: string | undefined;
    imageThumbnail?: string | undefined;
    status?: string | undefined;
    daysOfWeek?: number[] | undefined;
    daysOfWeekString?: string;
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    conversationContactIdentifier?: string | undefined;
    conversationContactType?: ContactType | undefined;
    website?: string | undefined;
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    hasPickupService?: boolean;
    hasReplacementTransportService?: boolean;
    created: Date;
    createdBy?: string | undefined;
    lastModified: Date;
    lastModifiedBy?: string | undefined;
    conversations: ConversationItem[];
    largeData?: GarageLookupLargeItem | undefined;
}

export abstract class Geometry implements IGeometry {
    factory?: GeometryFactory | undefined;
    userData?: any | undefined;
    srid?: number;
    precisionModel?: PrecisionModel | undefined;
    numGeometries?: number;
    isSimple?: boolean;
    isValid?: boolean;
    area?: number;
    length?: number;
    centroid?: Point | undefined;
    interiorPoint?: Point | undefined;
    pointOnSurface?: Point | undefined;
    envelope?: Geometry | undefined;
    envelopeInternal?: Envelope | undefined;
    isRectangle?: boolean;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.factory = _data["factory"] ? GeometryFactory.fromJS(_data["factory"]) : <any>undefined;
            this.userData = _data["userData"];
            this.srid = _data["srid"];
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            this.numGeometries = _data["numGeometries"];
            this.isSimple = _data["isSimple"];
            this.isValid = _data["isValid"];
            this.area = _data["area"];
            this.length = _data["length"];
            this.centroid = _data["centroid"] ? Point.fromJS(_data["centroid"]) : <any>undefined;
            this.interiorPoint = _data["interiorPoint"] ? Point.fromJS(_data["interiorPoint"]) : <any>undefined;
            this.pointOnSurface = _data["pointOnSurface"] ? Point.fromJS(_data["pointOnSurface"]) : <any>undefined;
            this.envelope = _data["envelope"] ? Geometry.fromJS(_data["envelope"]) : <any>undefined;
            this.envelopeInternal = _data["envelopeInternal"] ? Envelope.fromJS(_data["envelopeInternal"]) : <any>undefined;
            this.isRectangle = _data["isRectangle"];
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Geometry' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["factory"] = this.factory ? this.factory.toJSON() : <any>undefined;
        data["userData"] = this.userData;
        data["srid"] = this.srid;
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["numGeometries"] = this.numGeometries;
        data["isSimple"] = this.isSimple;
        data["isValid"] = this.isValid;
        data["area"] = this.area;
        data["length"] = this.length;
        data["centroid"] = this.centroid ? this.centroid.toJSON() : <any>undefined;
        data["interiorPoint"] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
        data["pointOnSurface"] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
        data["envelope"] = this.envelope ? this.envelope.toJSON() : <any>undefined;
        data["envelopeInternal"] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
        data["isRectangle"] = this.isRectangle;
        return data;
    }
}

export interface IGeometry {
    factory?: GeometryFactory | undefined;
    userData?: any | undefined;
    srid?: number;
    precisionModel?: PrecisionModel | undefined;
    numGeometries?: number;
    isSimple?: boolean;
    isValid?: boolean;
    area?: number;
    length?: number;
    centroid?: Point | undefined;
    interiorPoint?: Point | undefined;
    pointOnSurface?: Point | undefined;
    envelope?: Geometry | undefined;
    envelopeInternal?: Envelope | undefined;
    isRectangle?: boolean;
}

export class GeometryFactory implements IGeometryFactory {
    precisionModel?: PrecisionModel | undefined;
    coordinateSequenceFactory?: CoordinateSequenceFactory | undefined;
    srid?: number;
    geometryServices?: NtsGeometryServices | undefined;

    constructor(data?: IGeometryFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            this.coordinateSequenceFactory = _data["coordinateSequenceFactory"] ? CoordinateSequenceFactory.fromJS(_data["coordinateSequenceFactory"]) : <any>undefined;
            this.srid = _data["srid"];
            this.geometryServices = _data["geometryServices"] ? NtsGeometryServices.fromJS(_data["geometryServices"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeometryFactory {
        data = typeof data === 'object' ? data : {};
        let result = new GeometryFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["coordinateSequenceFactory"] = this.coordinateSequenceFactory ? this.coordinateSequenceFactory.toJSON() : <any>undefined;
        data["srid"] = this.srid;
        data["geometryServices"] = this.geometryServices ? this.geometryServices.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGeometryFactory {
    precisionModel?: PrecisionModel | undefined;
    coordinateSequenceFactory?: CoordinateSequenceFactory | undefined;
    srid?: number;
    geometryServices?: NtsGeometryServices | undefined;
}

export class PrecisionModel implements IPrecisionModel {
    isFloating?: boolean;
    maximumSignificantDigits?: number;
    scale?: number;
    gridSize?: number;
    precisionModelType?: PrecisionModels;

    constructor(data?: IPrecisionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFloating = _data["isFloating"];
            this.maximumSignificantDigits = _data["maximumSignificantDigits"];
            this.scale = _data["scale"];
            this.gridSize = _data["gridSize"];
            this.precisionModelType = _data["precisionModelType"];
        }
    }

    static fromJS(data: any): PrecisionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PrecisionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFloating"] = this.isFloating;
        data["maximumSignificantDigits"] = this.maximumSignificantDigits;
        data["scale"] = this.scale;
        data["gridSize"] = this.gridSize;
        data["precisionModelType"] = this.precisionModelType;
        return data;
    }
}

export interface IPrecisionModel {
    isFloating?: boolean;
    maximumSignificantDigits?: number;
    scale?: number;
    gridSize?: number;
    precisionModelType?: PrecisionModels;
}

export enum PrecisionModels {
    Floating = 0,
    FloatingSingle = 1,
    Fixed = 2,
}

export abstract class CoordinateSequenceFactory implements ICoordinateSequenceFactory {
    ordinates?: Ordinates;

    constructor(data?: ICoordinateSequenceFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ordinates = _data["ordinates"];
        }
    }

    static fromJS(data: any): CoordinateSequenceFactory {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CoordinateSequenceFactory' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordinates"] = this.ordinates;
        return data;
    }
}

export interface ICoordinateSequenceFactory {
    ordinates?: Ordinates;
}

export enum Ordinates {
    None = 0,
    X = 1,
    Spatial1 = 1,
    Y = 2,
    Spatial2 = 2,
    XY = 3,
    Spatial3 = 4,
    Z = 4,
    XYZ = 7,
    Spatial4 = 8,
    Spatial5 = 16,
    Spatial6 = 32,
    Spatial7 = 64,
    Spatial8 = 128,
    Spatial9 = 256,
    Spatial10 = 512,
    Spatial11 = 1024,
    Spatial12 = 2048,
    Spatial13 = 4096,
    Spatial14 = 8192,
    Spatial15 = 16384,
    Spatial16 = 32768,
    AllSpatialOrdinates = 65535,
    Measure1 = 65536,
    M = 65536,
    XYM = 65539,
    XYZM = 65543,
    Measure2 = 131072,
    Measure3 = 262144,
    Measure4 = 524288,
    Measure5 = 1048576,
    Measure6 = 2097152,
    Measure7 = 4194304,
    Measure8 = 8388608,
    Measure9 = 16777216,
    Measure10 = 33554432,
    Measure11 = 67108864,
    Measure12 = 134217728,
    Measure13 = 268435456,
    Measure14 = 536870912,
    Measure15 = 1073741824,
    Measure16 = -2147483648,
    AllMeasureOrdinates = -65536,
    AllOrdinates = -1,
}

export class NtsGeometryServices implements INtsGeometryServices {
    geometryOverlay?: GeometryOverlay | undefined;
    coordinateEqualityComparer?: CoordinateEqualityComparer | undefined;
    defaultSRID?: number;
    defaultCoordinateSequenceFactory?: CoordinateSequenceFactory | undefined;
    defaultPrecisionModel?: PrecisionModel | undefined;

    constructor(data?: INtsGeometryServices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.geometryOverlay = _data["geometryOverlay"] ? GeometryOverlay.fromJS(_data["geometryOverlay"]) : <any>undefined;
            this.coordinateEqualityComparer = _data["coordinateEqualityComparer"] ? CoordinateEqualityComparer.fromJS(_data["coordinateEqualityComparer"]) : <any>undefined;
            this.defaultSRID = _data["defaultSRID"];
            this.defaultCoordinateSequenceFactory = _data["defaultCoordinateSequenceFactory"] ? CoordinateSequenceFactory.fromJS(_data["defaultCoordinateSequenceFactory"]) : <any>undefined;
            this.defaultPrecisionModel = _data["defaultPrecisionModel"] ? PrecisionModel.fromJS(_data["defaultPrecisionModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NtsGeometryServices {
        data = typeof data === 'object' ? data : {};
        let result = new NtsGeometryServices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometryOverlay"] = this.geometryOverlay ? this.geometryOverlay.toJSON() : <any>undefined;
        data["coordinateEqualityComparer"] = this.coordinateEqualityComparer ? this.coordinateEqualityComparer.toJSON() : <any>undefined;
        data["defaultSRID"] = this.defaultSRID;
        data["defaultCoordinateSequenceFactory"] = this.defaultCoordinateSequenceFactory ? this.defaultCoordinateSequenceFactory.toJSON() : <any>undefined;
        data["defaultPrecisionModel"] = this.defaultPrecisionModel ? this.defaultPrecisionModel.toJSON() : <any>undefined;
        return data;
    }
}

export interface INtsGeometryServices {
    geometryOverlay?: GeometryOverlay | undefined;
    coordinateEqualityComparer?: CoordinateEqualityComparer | undefined;
    defaultSRID?: number;
    defaultCoordinateSequenceFactory?: CoordinateSequenceFactory | undefined;
    defaultPrecisionModel?: PrecisionModel | undefined;
}

export abstract class GeometryOverlay implements IGeometryOverlay {

    constructor(data?: IGeometryOverlay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GeometryOverlay {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'GeometryOverlay' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGeometryOverlay {
}

export abstract class EqualityComparerOfCoordinate implements IEqualityComparerOfCoordinate {

    constructor(data?: IEqualityComparerOfCoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): EqualityComparerOfCoordinate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EqualityComparerOfCoordinate' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IEqualityComparerOfCoordinate {
}

export class CoordinateEqualityComparer extends EqualityComparerOfCoordinate implements ICoordinateEqualityComparer {

    constructor(data?: ICoordinateEqualityComparer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CoordinateEqualityComparer {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinateEqualityComparer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICoordinateEqualityComparer extends IEqualityComparerOfCoordinate {
}

export class Point extends Geometry implements IPoint {
    coordinateSequence?: CoordinateSequence | undefined;
    coordinates?: Coordinate[] | undefined;
    numPoints?: number;
    isEmpty?: boolean;
    dimension?: Dimension;
    boundaryDimension?: Dimension;
    x?: number;
    y?: number;
    coordinate?: Coordinate | undefined;
    geometryType?: string | undefined;
    ogcGeometryType?: OgcGeometryType;
    boundary?: Geometry | undefined;
    z?: number;
    m?: number;

    constructor(data?: IPoint) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.coordinateSequence = _data["coordinateSequence"] ? CoordinateSequence.fromJS(_data["coordinateSequence"]) : <any>undefined;
            if (Array.isArray(_data["coordinates"])) {
                this.coordinates = [] as any;
                for (let item of _data["coordinates"])
                    this.coordinates!.push(Coordinate.fromJS(item));
            }
            this.numPoints = _data["numPoints"];
            this.isEmpty = _data["isEmpty"];
            this.dimension = _data["dimension"];
            this.boundaryDimension = _data["boundaryDimension"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.coordinate = _data["coordinate"] ? Coordinate.fromJS(_data["coordinate"]) : <any>undefined;
            this.geometryType = _data["geometryType"];
            this.ogcGeometryType = _data["ogcGeometryType"];
            this.boundary = _data["boundary"] ? Geometry.fromJS(_data["boundary"]) : <any>undefined;
            this.z = _data["z"];
            this.m = _data["m"];
        }
    }

    static fromJS(data: any): Point {
        data = typeof data === 'object' ? data : {};
        let result = new Point();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coordinateSequence"] = this.coordinateSequence ? this.coordinateSequence.toJSON() : <any>undefined;
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item.toJSON());
        }
        data["numPoints"] = this.numPoints;
        data["isEmpty"] = this.isEmpty;
        data["dimension"] = this.dimension;
        data["boundaryDimension"] = this.boundaryDimension;
        data["x"] = this.x;
        data["y"] = this.y;
        data["coordinate"] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
        data["geometryType"] = this.geometryType;
        data["ogcGeometryType"] = this.ogcGeometryType;
        data["boundary"] = this.boundary ? this.boundary.toJSON() : <any>undefined;
        data["z"] = this.z;
        data["m"] = this.m;
        super.toJSON(data);
        return data;
    }
}

export interface IPoint extends IGeometry {
    coordinateSequence?: CoordinateSequence | undefined;
    coordinates?: Coordinate[] | undefined;
    numPoints?: number;
    isEmpty?: boolean;
    dimension?: Dimension;
    boundaryDimension?: Dimension;
    x?: number;
    y?: number;
    coordinate?: Coordinate | undefined;
    geometryType?: string | undefined;
    ogcGeometryType?: OgcGeometryType;
    boundary?: Geometry | undefined;
    z?: number;
    m?: number;
}

export abstract class CoordinateSequence implements ICoordinateSequence {
    dimension?: number;
    measures?: number;
    spatial?: number;
    ordinates?: Ordinates;
    hasZ?: boolean;
    hasM?: boolean;
    zOrdinateIndex?: number;
    mOrdinateIndex?: number;
    first?: Coordinate | undefined;
    last?: Coordinate | undefined;
    count?: number;

    constructor(data?: ICoordinateSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dimension = _data["dimension"];
            this.measures = _data["measures"];
            this.spatial = _data["spatial"];
            this.ordinates = _data["ordinates"];
            this.hasZ = _data["hasZ"];
            this.hasM = _data["hasM"];
            this.zOrdinateIndex = _data["zOrdinateIndex"];
            this.mOrdinateIndex = _data["mOrdinateIndex"];
            this.first = _data["first"] ? Coordinate.fromJS(_data["first"]) : <any>undefined;
            this.last = _data["last"] ? Coordinate.fromJS(_data["last"]) : <any>undefined;
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CoordinateSequence {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CoordinateSequence' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension;
        data["measures"] = this.measures;
        data["spatial"] = this.spatial;
        data["ordinates"] = this.ordinates;
        data["hasZ"] = this.hasZ;
        data["hasM"] = this.hasM;
        data["zOrdinateIndex"] = this.zOrdinateIndex;
        data["mOrdinateIndex"] = this.mOrdinateIndex;
        data["first"] = this.first ? this.first.toJSON() : <any>undefined;
        data["last"] = this.last ? this.last.toJSON() : <any>undefined;
        data["count"] = this.count;
        return data;
    }
}

export interface ICoordinateSequence {
    dimension?: number;
    measures?: number;
    spatial?: number;
    ordinates?: Ordinates;
    hasZ?: boolean;
    hasM?: boolean;
    zOrdinateIndex?: number;
    mOrdinateIndex?: number;
    first?: Coordinate | undefined;
    last?: Coordinate | undefined;
    count?: number;
}

export class Coordinate implements ICoordinate {
    x?: number;
    y?: number;
    z?: number;
    m?: number;
    coordinateValue?: Coordinate | undefined;
    isValid?: boolean;

    constructor(data?: ICoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
            this.z = _data["z"];
            this.m = _data["m"];
            this.coordinateValue = _data["coordinateValue"] ? Coordinate.fromJS(_data["coordinateValue"]) : <any>undefined;
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): Coordinate {
        data = typeof data === 'object' ? data : {};
        let result = new Coordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        data["z"] = this.z;
        data["m"] = this.m;
        data["coordinateValue"] = this.coordinateValue ? this.coordinateValue.toJSON() : <any>undefined;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface ICoordinate {
    x?: number;
    y?: number;
    z?: number;
    m?: number;
    coordinateValue?: Coordinate | undefined;
    isValid?: boolean;
}

export enum Dimension {
    P = 0,
    Point = 0,
    Curve = 1,
    L = 1,
    A = 2,
    Surface = 2,
    Collapse = 3,
    Dontcare = -3,
    True = -2,
    Unknown = -1,
    False = -1,
}

export enum OgcGeometryType {
    Point = 1,
    LineString = 2,
    Polygon = 3,
    MultiPoint = 4,
    MultiLineString = 5,
    MultiPolygon = 6,
    GeometryCollection = 7,
    CircularString = 8,
    CompoundCurve = 9,
    CurvePolygon = 10,
    MultiCurve = 11,
    MultiSurface = 12,
    Curve = 13,
    Surface = 14,
    PolyhedralSurface = 15,
    TIN = 16,
}

export class Envelope implements IEnvelope {
    isNull?: boolean;
    width?: number;
    height?: number;
    diameter?: number;
    minX?: number;
    maxX?: number;
    minY?: number;
    maxY?: number;
    area?: number;
    minExtent?: number;
    maxExtent?: number;
    centre?: Coordinate | undefined;

    constructor(data?: IEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNull = _data["isNull"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.diameter = _data["diameter"];
            this.minX = _data["minX"];
            this.maxX = _data["maxX"];
            this.minY = _data["minY"];
            this.maxY = _data["maxY"];
            this.area = _data["area"];
            this.minExtent = _data["minExtent"];
            this.maxExtent = _data["maxExtent"];
            this.centre = _data["centre"] ? Coordinate.fromJS(_data["centre"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Envelope {
        data = typeof data === 'object' ? data : {};
        let result = new Envelope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNull"] = this.isNull;
        data["width"] = this.width;
        data["height"] = this.height;
        data["diameter"] = this.diameter;
        data["minX"] = this.minX;
        data["maxX"] = this.maxX;
        data["minY"] = this.minY;
        data["maxY"] = this.maxY;
        data["area"] = this.area;
        data["minExtent"] = this.minExtent;
        data["maxExtent"] = this.maxExtent;
        data["centre"] = this.centre ? this.centre.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEnvelope {
    isNull?: boolean;
    width?: number;
    height?: number;
    diameter?: number;
    minX?: number;
    maxX?: number;
    minY?: number;
    maxY?: number;
    area?: number;
    minExtent?: number;
    maxExtent?: number;
    centre?: Coordinate | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: string;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: string;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class ConversationItem extends BaseAuditableEntity implements IConversationItem {
    priority?: PriorityLevel;
    vehicleLicensePlate!: string;
    relatedVehicleLookup?: VehicleLookupItem;
    relatedGarageLookupIdentifier!: string;
    relatedGarageLookup?: GarageLookupItem;
    relatedServiceTypes?: GarageServiceType[];
    relatedServiceTypesString!: string;
    conversationType!: ConversationType;
    messages?: ConversationMessageItem[];

    constructor(data?: IConversationItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.priority = _data["priority"];
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.relatedVehicleLookup = _data["relatedVehicleLookup"] ? VehicleLookupItem.fromJS(_data["relatedVehicleLookup"]) : <any>undefined;
            this.relatedGarageLookupIdentifier = _data["relatedGarageLookupIdentifier"];
            this.relatedGarageLookup = _data["relatedGarageLookup"] ? GarageLookupItem.fromJS(_data["relatedGarageLookup"]) : <any>undefined;
            if (Array.isArray(_data["relatedServiceTypes"])) {
                this.relatedServiceTypes = [] as any;
                for (let item of _data["relatedServiceTypes"])
                    this.relatedServiceTypes!.push(item);
            }
            this.relatedServiceTypesString = _data["relatedServiceTypesString"];
            this.conversationType = _data["conversationType"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ConversationMessageItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConversationItem {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority;
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["relatedVehicleLookup"] = this.relatedVehicleLookup ? this.relatedVehicleLookup.toJSON() : <any>undefined;
        data["relatedGarageLookupIdentifier"] = this.relatedGarageLookupIdentifier;
        data["relatedGarageLookup"] = this.relatedGarageLookup ? this.relatedGarageLookup.toJSON() : <any>undefined;
        if (Array.isArray(this.relatedServiceTypes)) {
            data["relatedServiceTypes"] = [];
            for (let item of this.relatedServiceTypes)
                data["relatedServiceTypes"].push(item);
        }
        data["relatedServiceTypesString"] = this.relatedServiceTypesString;
        data["conversationType"] = this.conversationType;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IConversationItem extends IBaseAuditableEntity {
    priority?: PriorityLevel;
    vehicleLicensePlate: string;
    relatedVehicleLookup?: VehicleLookupItem;
    relatedGarageLookupIdentifier: string;
    relatedGarageLookup?: GarageLookupItem;
    relatedServiceTypes?: GarageServiceType[];
    relatedServiceTypesString: string;
    conversationType: ConversationType;
    messages?: ConversationMessageItem[];
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class VehicleLookupItem implements IVehicleLookupItem {
    licensePlate!: string;
    dateOfMOTExpiry!: Date;
    dateOfAscription!: Date;
    location?: Geometry | undefined;
    reporterPhoneNumber?: string | undefined;
    reporterWhatsappNumber?: string | undefined;
    reporterEmailAddress?: string | undefined;
    created!: Date;
    createdBy?: string | undefined;
    lastModified!: Date;
    lastModifiedBy?: string | undefined;
    timeline!: VehicleTimelineItem[];
    conversations!: ConversationItem[];
    serviceLogs!: VehicleServiceLogItem[];

    constructor(data?: IVehicleLookupItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.timeline = [];
            this.conversations = [];
            this.serviceLogs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.licensePlate = _data["licensePlate"];
            this.dateOfMOTExpiry = _data["dateOfMOTExpiry"] ? new Date(_data["dateOfMOTExpiry"].toString()) : <any>undefined;
            this.dateOfAscription = _data["dateOfAscription"] ? new Date(_data["dateOfAscription"].toString()) : <any>undefined;
            this.location = _data["location"] ? Geometry.fromJS(_data["location"]) : <any>undefined;
            this.reporterPhoneNumber = _data["reporterPhoneNumber"];
            this.reporterWhatsappNumber = _data["reporterWhatsappNumber"];
            this.reporterEmailAddress = _data["reporterEmailAddress"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            if (Array.isArray(_data["timeline"])) {
                this.timeline = [] as any;
                for (let item of _data["timeline"])
                    this.timeline!.push(VehicleTimelineItem.fromJS(item));
            }
            if (Array.isArray(_data["conversations"])) {
                this.conversations = [] as any;
                for (let item of _data["conversations"])
                    this.conversations!.push(ConversationItem.fromJS(item));
            }
            if (Array.isArray(_data["serviceLogs"])) {
                this.serviceLogs = [] as any;
                for (let item of _data["serviceLogs"])
                    this.serviceLogs!.push(VehicleServiceLogItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleLookupItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleLookupItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licensePlate"] = this.licensePlate;
        data["dateOfMOTExpiry"] = this.dateOfMOTExpiry ? this.dateOfMOTExpiry.toISOString() : <any>undefined;
        data["dateOfAscription"] = this.dateOfAscription ? this.dateOfAscription.toISOString() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["reporterPhoneNumber"] = this.reporterPhoneNumber;
        data["reporterWhatsappNumber"] = this.reporterWhatsappNumber;
        data["reporterEmailAddress"] = this.reporterEmailAddress;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        if (Array.isArray(this.timeline)) {
            data["timeline"] = [];
            for (let item of this.timeline)
                data["timeline"].push(item.toJSON());
        }
        if (Array.isArray(this.conversations)) {
            data["conversations"] = [];
            for (let item of this.conversations)
                data["conversations"].push(item.toJSON());
        }
        if (Array.isArray(this.serviceLogs)) {
            data["serviceLogs"] = [];
            for (let item of this.serviceLogs)
                data["serviceLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleLookupItem {
    licensePlate: string;
    dateOfMOTExpiry: Date;
    dateOfAscription: Date;
    location?: Geometry | undefined;
    reporterPhoneNumber?: string | undefined;
    reporterWhatsappNumber?: string | undefined;
    reporterEmailAddress?: string | undefined;
    created: Date;
    createdBy?: string | undefined;
    lastModified: Date;
    lastModifiedBy?: string | undefined;
    timeline: VehicleTimelineItem[];
    conversations: ConversationItem[];
    serviceLogs: VehicleServiceLogItem[];
}

export class VehicleTimelineItem extends BaseEntity implements IVehicleTimelineItem {
    vehicleLicensePlate!: string;
    vehicleLookup?: VehicleLookupItem;
    title!: string;
    description!: string;
    date!: Date;
    type!: VehicleTimelineType;
    priority!: VehicleTimelinePriority;
    extraDataTableJson?: string;
    extraData?: TupleOfStringAndString[];

    constructor(data?: IVehicleTimelineItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.vehicleLookup = _data["vehicleLookup"] ? VehicleLookupItem.fromJS(_data["vehicleLookup"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.priority = _data["priority"];
            this.extraDataTableJson = _data["extraDataTableJson"];
            if (Array.isArray(_data["extraData"])) {
                this.extraData = [] as any;
                for (let item of _data["extraData"])
                    this.extraData!.push(TupleOfStringAndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleTimelineItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTimelineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["vehicleLookup"] = this.vehicleLookup ? this.vehicleLookup.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["priority"] = this.priority;
        data["extraDataTableJson"] = this.extraDataTableJson;
        if (Array.isArray(this.extraData)) {
            data["extraData"] = [];
            for (let item of this.extraData)
                data["extraData"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVehicleTimelineItem extends IBaseEntity {
    vehicleLicensePlate: string;
    vehicleLookup?: VehicleLookupItem;
    title: string;
    description: string;
    date: Date;
    type: VehicleTimelineType;
    priority: VehicleTimelinePriority;
    extraDataTableJson?: string;
    extraData?: TupleOfStringAndString[];
}

export enum VehicleTimelineType {
    Unknown = 0,
    SucceededMOT = 1,
    FailedMOT = 2,
    Service = 3,
    Repair = 4,
    OwnerChange = 5,
}

export enum VehicleTimelinePriority {
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TupleOfStringAndString implements ITupleOfStringAndString {
    item1?: string;
    item2?: string;

    constructor(data?: ITupleOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): TupleOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface ITupleOfStringAndString {
    item1?: string;
    item2?: string;
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class VehicleServiceLogItem extends BaseAuditableEntity implements IVehicleServiceLogItem {
    vehicleLicensePlate!: string;
    vehicleLookup?: VehicleLookupItem;
    garageLookupIdentifier!: string;
    garageLookup?: GarageLookupItem | undefined;
    type!: GarageServiceType;
    description?: string | undefined;
    attachedFile?: string | undefined;
    notes?: string;
    date!: Date;
    expectedNextDate?: Date | undefined;
    odometerReading!: number;
    expectedNextOdometerReading?: number | undefined;
    status!: VehicleServiceLogStatus;
    reporterName!: string;
    reporterPhoneNumber?: string | undefined;
    reporterEmailAddress?: string | undefined;
    metaData?: string;

    constructor(data?: IVehicleServiceLogItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.vehicleLookup = _data["vehicleLookup"] ? VehicleLookupItem.fromJS(_data["vehicleLookup"]) : <any>undefined;
            this.garageLookupIdentifier = _data["garageLookupIdentifier"];
            this.garageLookup = _data["garageLookup"] ? GarageLookupItem.fromJS(_data["garageLookup"]) : <any>undefined;
            this.type = _data["type"];
            this.description = _data["description"];
            this.attachedFile = _data["attachedFile"];
            this.notes = _data["notes"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.expectedNextDate = _data["expectedNextDate"] ? new Date(_data["expectedNextDate"].toString()) : <any>undefined;
            this.odometerReading = _data["odometerReading"];
            this.expectedNextOdometerReading = _data["expectedNextOdometerReading"];
            this.status = _data["status"];
            this.reporterName = _data["reporterName"];
            this.reporterPhoneNumber = _data["reporterPhoneNumber"];
            this.reporterEmailAddress = _data["reporterEmailAddress"];
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): VehicleServiceLogItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleServiceLogItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["vehicleLookup"] = this.vehicleLookup ? this.vehicleLookup.toJSON() : <any>undefined;
        data["garageLookupIdentifier"] = this.garageLookupIdentifier;
        data["garageLookup"] = this.garageLookup ? this.garageLookup.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["description"] = this.description;
        data["attachedFile"] = this.attachedFile;
        data["notes"] = this.notes;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["expectedNextDate"] = this.expectedNextDate ? this.expectedNextDate.toISOString() : <any>undefined;
        data["odometerReading"] = this.odometerReading;
        data["expectedNextOdometerReading"] = this.expectedNextOdometerReading;
        data["status"] = this.status;
        data["reporterName"] = this.reporterName;
        data["reporterPhoneNumber"] = this.reporterPhoneNumber;
        data["reporterEmailAddress"] = this.reporterEmailAddress;
        data["metaData"] = this.metaData;
        super.toJSON(data);
        return data;
    }
}

export interface IVehicleServiceLogItem extends IBaseAuditableEntity {
    vehicleLicensePlate: string;
    vehicleLookup?: VehicleLookupItem;
    garageLookupIdentifier: string;
    garageLookup?: GarageLookupItem | undefined;
    type: GarageServiceType;
    description?: string | undefined;
    attachedFile?: string | undefined;
    notes?: string;
    date: Date;
    expectedNextDate?: Date | undefined;
    odometerReading: number;
    expectedNextOdometerReading?: number | undefined;
    status: VehicleServiceLogStatus;
    reporterName: string;
    reporterPhoneNumber?: string | undefined;
    reporterEmailAddress?: string | undefined;
    metaData?: string;
}

export enum VehicleServiceLogStatus {
    NotVerified = 0,
    VerifiedByGarage = 1,
}

export class ConversationMessageItem extends BaseAuditableEntity implements IConversationMessageItem {
    conversationId!: string;
    conversation?: ConversationItem;
    senderContactType!: ContactType;
    senderContactIdentifier!: string;
    receiverContactType!: ContactType;
    receiverContactIdentifier!: string;
    status!: MessageStatus;
    messageContent!: string;
    errorMessage?: string | undefined;

    constructor(data?: IConversationMessageItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.conversationId = _data["conversationId"];
            this.conversation = _data["conversation"] ? ConversationItem.fromJS(_data["conversation"]) : <any>undefined;
            this.senderContactType = _data["senderContactType"];
            this.senderContactIdentifier = _data["senderContactIdentifier"];
            this.receiverContactType = _data["receiverContactType"];
            this.receiverContactIdentifier = _data["receiverContactIdentifier"];
            this.status = _data["status"];
            this.messageContent = _data["messageContent"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ConversationMessageItem {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationMessageItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversationId"] = this.conversationId;
        data["conversation"] = this.conversation ? this.conversation.toJSON() : <any>undefined;
        data["senderContactType"] = this.senderContactType;
        data["senderContactIdentifier"] = this.senderContactIdentifier;
        data["receiverContactType"] = this.receiverContactType;
        data["receiverContactIdentifier"] = this.receiverContactIdentifier;
        data["status"] = this.status;
        data["messageContent"] = this.messageContent;
        data["errorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IConversationMessageItem extends IBaseAuditableEntity {
    conversationId: string;
    conversation?: ConversationItem;
    senderContactType: ContactType;
    senderContactIdentifier: string;
    receiverContactType: ContactType;
    receiverContactIdentifier: string;
    status: MessageStatus;
    messageContent: string;
    errorMessage?: string | undefined;
}

export enum MessageStatus {
    Pending = 0,
    Sent = 1,
    Delivered = 2,
    Failed = 3,
}

export class GarageLookupLargeItem extends BaseEntity implements IGarageLookupLargeItem {
    googleApiDetailsJson?: string;

    constructor(data?: IGarageLookupLargeItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.googleApiDetailsJson = _data["googleApiDetailsJson"];
        }
    }

    static fromJS(data: any): GarageLookupLargeItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupLargeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleApiDetailsJson"] = this.googleApiDetailsJson;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageLookupLargeItem extends IBaseEntity {
    googleApiDetailsJson?: string;
}

export abstract class IQueueService implements IIQueueService {

    constructor(data?: IIQueueService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IQueueService {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IQueueService' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIQueueService {
}

export class GarageItemDto implements IGarageItemDto {
    name?: string;
    email?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    location?: GarageLocationItem;
    bankingDetails?: GarageBankingDetailsItem;

    constructor(data?: IGarageItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsAppNumber = _data["whatsAppNumber"];
            this.location = _data["location"] ? GarageLocationItem.fromJS(_data["location"]) : <any>undefined;
            this.bankingDetails = _data["bankingDetails"] ? GarageBankingDetailsItem.fromJS(_data["bankingDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GarageItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsAppNumber"] = this.whatsAppNumber;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["bankingDetails"] = this.bankingDetails ? this.bankingDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGarageItemDto {
    name?: string;
    email?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    location?: GarageLocationItem;
    bankingDetails?: GarageBankingDetailsItem;
}

export class GarageLocationItem extends BaseEntity implements IGarageLocationItem {
    address!: string;
    city!: string;
    postalCode!: string;
    country!: string;
    longitude!: number;
    latitude!: number;

    constructor(data?: IGarageLocationItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.address = _data["address"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): GarageLocationItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLocationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageLocationItem extends IBaseEntity {
    address: string;
    city: string;
    postalCode: string;
    country: string;
    longitude: number;
    latitude: number;
}

export class GarageBankingDetailsItem extends BaseEntity implements IGarageBankingDetailsItem {
    bankName?: string;
    kvKNumber?: string;
    accountHolderName?: string;
    iban?: string;

    constructor(data?: IGarageBankingDetailsItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bankName = _data["bankName"];
            this.kvKNumber = _data["kvKNumber"];
            this.accountHolderName = _data["accountHolderName"];
            this.iban = _data["iban"];
        }
    }

    static fromJS(data: any): GarageBankingDetailsItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageBankingDetailsItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["kvKNumber"] = this.kvKNumber;
        data["accountHolderName"] = this.accountHolderName;
        data["iban"] = this.iban;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageBankingDetailsItem extends IBaseEntity {
    bankName?: string;
    kvKNumber?: string;
    accountHolderName?: string;
    iban?: string;
}

export class GarageOverview implements IGarageOverview {
    name?: string;
    vehicles?: VehicleLookupItem[];

    constructor(data?: IGarageOverview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(VehicleLookupItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GarageOverview {
        data = typeof data === 'object' ? data : {};
        let result = new GarageOverview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGarageOverview {
    name?: string;
    vehicles?: VehicleLookupItem[];
}

export class GarageServiceItemDto implements IGarageServiceItemDto {
    id?: string;
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;
    status?: number;

    constructor(data?: IGarageServiceItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.durationInMinutes = _data["durationInMinutes"];
            this.price = _data["price"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GarageServiceItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageServiceItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["description"] = this.description;
        data["durationInMinutes"] = this.durationInMinutes;
        data["price"] = this.price;
        data["status"] = this.status;
        return data;
    }
}

export interface IGarageServiceItemDto {
    id?: string;
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;
    status?: number;
}

export class GarageEmployeeItemDto implements IGarageEmployeeItemDto {
    id?: string;
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItem[];
    workExperiences?: GarageEmployeeWorkExperienceItem[];

    constructor(data?: IGarageEmployeeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
            this.contact = _data["contact"] ? GarageEmployeeContactItem.fromJS(_data["contact"]) : <any>undefined;
            if (Array.isArray(_data["workSchema"])) {
                this.workSchema = [] as any;
                for (let item of _data["workSchema"])
                    this.workSchema!.push(GarageEmployeeWorkSchemaItem.fromJS(item));
            }
            if (Array.isArray(_data["workExperiences"])) {
                this.workExperiences = [] as any;
                for (let item of _data["workExperiences"])
                    this.workExperiences!.push(GarageEmployeeWorkExperienceItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GarageEmployeeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.workSchema)) {
            data["workSchema"] = [];
            for (let item of this.workSchema)
                data["workSchema"].push(item.toJSON());
        }
        if (Array.isArray(this.workExperiences)) {
            data["workExperiences"] = [];
            for (let item of this.workExperiences)
                data["workExperiences"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGarageEmployeeItemDto {
    id?: string;
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItem[];
    workExperiences?: GarageEmployeeWorkExperienceItem[];
}

export class GarageEmployeeContactItem extends BaseEntity implements IGarageEmployeeContactItem {
    fullName!: string;
    phoneNumber?: string;
    email?: string;

    constructor(data?: IGarageEmployeeContactItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GarageEmployeeContactItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeContactItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageEmployeeContactItem extends IBaseEntity {
    fullName: string;
    phoneNumber?: string;
    email?: string;
}

export class GarageEmployeeWorkSchemaItem extends BaseEntity implements IGarageEmployeeWorkSchemaItem {
    employeeId!: string;
    weekOfYear?: number;
    dayOfWeek!: number;
    startTime!: Date;
    endTime!: Date;
    notes?: string;

    constructor(data?: IGarageEmployeeWorkSchemaItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.weekOfYear = _data["weekOfYear"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): GarageEmployeeWorkSchemaItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeWorkSchemaItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["weekOfYear"] = this.weekOfYear;
        data["dayOfWeek"] = this.dayOfWeek;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageEmployeeWorkSchemaItem extends IBaseEntity {
    employeeId: string;
    weekOfYear?: number;
    dayOfWeek: number;
    startTime: Date;
    endTime: Date;
    notes?: string;
}

export class GarageEmployeeWorkExperienceItem extends BaseEntity implements IGarageEmployeeWorkExperienceItem {
    garageId!: string;
    employeeId!: string;
    serviceId!: string;
    description!: string;

    constructor(data?: IGarageEmployeeWorkExperienceItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.garageId = _data["garageId"];
            this.employeeId = _data["employeeId"];
            this.serviceId = _data["serviceId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GarageEmployeeWorkExperienceItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeWorkExperienceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garageId"] = this.garageId;
        data["employeeId"] = this.employeeId;
        data["serviceId"] = this.serviceId;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageEmployeeWorkExperienceItem extends IBaseEntity {
    garageId: string;
    employeeId: string;
    serviceId: string;
    description: string;
}

export class GarageItem extends BaseAuditableEntity implements IGarageItem {
    userId?: string;
    name?: string;
    email?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    location?: GarageLocationItem;
    bankingDetails?: GarageBankingDetailsItem;
    employees?: GarageEmployeeItem[];

    constructor(data?: IGarageItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsAppNumber = _data["whatsAppNumber"];
            this.location = _data["location"] ? GarageLocationItem.fromJS(_data["location"]) : <any>undefined;
            this.bankingDetails = _data["bankingDetails"] ? GarageBankingDetailsItem.fromJS(_data["bankingDetails"]) : <any>undefined;
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(GarageEmployeeItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GarageItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsAppNumber"] = this.whatsAppNumber;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["bankingDetails"] = this.bankingDetails ? this.bankingDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGarageItem extends IBaseAuditableEntity {
    userId?: string;
    name?: string;
    email?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    location?: GarageLocationItem;
    bankingDetails?: GarageBankingDetailsItem;
    employees?: GarageEmployeeItem[];
}

export class GarageEmployeeItem extends BaseAuditableEntity implements IGarageEmployeeItem {
    userId?: string;
    garageId?: string;
    garage?: GarageItem;
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItem[];
    workExperiences?: GarageEmployeeWorkExperienceItem[];

    constructor(data?: IGarageEmployeeItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.garageId = _data["garageId"];
            this.garage = _data["garage"] ? GarageItem.fromJS(_data["garage"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.contact = _data["contact"] ? GarageEmployeeContactItem.fromJS(_data["contact"]) : <any>undefined;
            if (Array.isArray(_data["workSchema"])) {
                this.workSchema = [] as any;
                for (let item of _data["workSchema"])
                    this.workSchema!.push(GarageEmployeeWorkSchemaItem.fromJS(item));
            }
            if (Array.isArray(_data["workExperiences"])) {
                this.workExperiences = [] as any;
                for (let item of _data["workExperiences"])
                    this.workExperiences!.push(GarageEmployeeWorkExperienceItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GarageEmployeeItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["garageId"] = this.garageId;
        data["garage"] = this.garage ? this.garage.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.workSchema)) {
            data["workSchema"] = [];
            for (let item of this.workSchema)
                data["workSchema"].push(item.toJSON());
        }
        if (Array.isArray(this.workExperiences)) {
            data["workExperiences"] = [];
            for (let item of this.workExperiences)
                data["workExperiences"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGarageEmployeeItem extends IBaseAuditableEntity {
    userId?: string;
    garageId?: string;
    garage?: GarageItem;
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItem[];
    workExperiences?: GarageEmployeeWorkExperienceItem[];
}

export class CreateGarageCommand implements ICreateGarageCommand {
    name?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    email?: string;
    location?: BriefLocationDto;
    bankingDetails?: BriefBankingDetailsDto;

    constructor(data?: ICreateGarageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsAppNumber = _data["whatsAppNumber"];
            this.email = _data["email"];
            this.location = _data["location"] ? BriefLocationDto.fromJS(_data["location"]) : <any>undefined;
            this.bankingDetails = _data["bankingDetails"] ? BriefBankingDetailsDto.fromJS(_data["bankingDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateGarageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGarageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsAppNumber"] = this.whatsAppNumber;
        data["email"] = this.email;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["bankingDetails"] = this.bankingDetails ? this.bankingDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateGarageCommand {
    name?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    email?: string;
    location?: BriefLocationDto;
    bankingDetails?: BriefBankingDetailsDto;
}

export class BriefLocationDto implements IBriefLocationDto {
    address?: string;
    postalCode?: string;
    city?: string;
    country?: string;
    longitude?: number;
    latitude?: number;

    constructor(data?: IBriefLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): BriefLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BriefLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["country"] = this.country;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export interface IBriefLocationDto {
    address?: string;
    postalCode?: string;
    city?: string;
    country?: string;
    longitude?: number;
    latitude?: number;
}

export class BriefBankingDetailsDto implements IBriefBankingDetailsDto {
    bankName?: string;
    kvKNumber?: string;
    accountHolderName?: string;
    iban?: string;

    constructor(data?: IBriefBankingDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.kvKNumber = _data["kvKNumber"];
            this.accountHolderName = _data["accountHolderName"];
            this.iban = _data["iban"];
        }
    }

    static fromJS(data: any): BriefBankingDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BriefBankingDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["kvKNumber"] = this.kvKNumber;
        data["accountHolderName"] = this.accountHolderName;
        data["iban"] = this.iban;
        return data;
    }
}

export interface IBriefBankingDetailsDto {
    bankName?: string;
    kvKNumber?: string;
    accountHolderName?: string;
    iban?: string;
}

export class GarageServiceItem extends BaseAuditableEntity implements IGarageServiceItem {
    userId?: string;
    garageId?: string;
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;
    status?: number;

    constructor(data?: IGarageServiceItem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.garageId = _data["garageId"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.durationInMinutes = _data["durationInMinutes"];
            this.price = _data["price"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GarageServiceItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageServiceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["garageId"] = this.garageId;
        data["type"] = this.type;
        data["description"] = this.description;
        data["durationInMinutes"] = this.durationInMinutes;
        data["price"] = this.price;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IGarageServiceItem extends IBaseAuditableEntity {
    userId?: string;
    garageId?: string;
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;
    status?: number;
}

export class CreateGarageServiceCommand implements ICreateGarageServiceCommand {
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;

    constructor(data?: ICreateGarageServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.description = _data["description"];
            this.durationInMinutes = _data["durationInMinutes"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): CreateGarageServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGarageServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["durationInMinutes"] = this.durationInMinutes;
        data["price"] = this.price;
        return data;
    }
}

export interface ICreateGarageServiceCommand {
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;
}

export class CreateGarageEmployeeCommand implements ICreateGarageEmployeeCommand {
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItemDto[];
    workExperiences?: GarageEmployeeWorkExperienceItemDto[];

    constructor(data?: ICreateGarageEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"];
            this.contact = _data["contact"] ? GarageEmployeeContactItem.fromJS(_data["contact"]) : <any>undefined;
            if (Array.isArray(_data["workSchema"])) {
                this.workSchema = [] as any;
                for (let item of _data["workSchema"])
                    this.workSchema!.push(GarageEmployeeWorkSchemaItemDto.fromJS(item));
            }
            if (Array.isArray(_data["workExperiences"])) {
                this.workExperiences = [] as any;
                for (let item of _data["workExperiences"])
                    this.workExperiences!.push(GarageEmployeeWorkExperienceItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateGarageEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGarageEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.workSchema)) {
            data["workSchema"] = [];
            for (let item of this.workSchema)
                data["workSchema"].push(item.toJSON());
        }
        if (Array.isArray(this.workExperiences)) {
            data["workExperiences"] = [];
            for (let item of this.workExperiences)
                data["workExperiences"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateGarageEmployeeCommand {
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItemDto[];
    workExperiences?: GarageEmployeeWorkExperienceItemDto[];
}

export class GarageEmployeeWorkSchemaItemDto implements IGarageEmployeeWorkSchemaItemDto {
    weekOfYear?: number;
    dayOfWeek!: number;
    startTime!: Date;
    endTime!: Date;
    notes?: string;

    constructor(data?: IGarageEmployeeWorkSchemaItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weekOfYear = _data["weekOfYear"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): GarageEmployeeWorkSchemaItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeWorkSchemaItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weekOfYear"] = this.weekOfYear;
        data["dayOfWeek"] = this.dayOfWeek;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IGarageEmployeeWorkSchemaItemDto {
    weekOfYear?: number;
    dayOfWeek: number;
    startTime: Date;
    endTime: Date;
    notes?: string;
}

export class GarageEmployeeWorkExperienceItemDto implements IGarageEmployeeWorkExperienceItemDto {
    serviceId!: string;
    description!: string;

    constructor(data?: IGarageEmployeeWorkExperienceItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GarageEmployeeWorkExperienceItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageEmployeeWorkExperienceItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["description"] = this.description;
        return data;
    }
}

export interface IGarageEmployeeWorkExperienceItemDto {
    serviceId: string;
    description: string;
}

export class UpdateGarageSettingsCommand implements IUpdateGarageSettingsCommand {
    name?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    email?: string;
    location?: GarageLocationItem;
    bankingDetails?: GarageBankingDetailsItem;

    constructor(data?: IUpdateGarageSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsAppNumber = _data["whatsAppNumber"];
            this.email = _data["email"];
            this.location = _data["location"] ? GarageLocationItem.fromJS(_data["location"]) : <any>undefined;
            this.bankingDetails = _data["bankingDetails"] ? GarageBankingDetailsItem.fromJS(_data["bankingDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateGarageSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGarageSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsAppNumber"] = this.whatsAppNumber;
        data["email"] = this.email;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["bankingDetails"] = this.bankingDetails ? this.bankingDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateGarageSettingsCommand {
    name?: string;
    phoneNumber?: string;
    whatsAppNumber?: string;
    email?: string;
    location?: GarageLocationItem;
    bankingDetails?: GarageBankingDetailsItem;
}

export class UpdateGarageServiceCommand implements IUpdateGarageServiceCommand {
    id?: string;
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;

    constructor(data?: IUpdateGarageServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.durationInMinutes = _data["durationInMinutes"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): UpdateGarageServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGarageServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["description"] = this.description;
        data["durationInMinutes"] = this.durationInMinutes;
        data["price"] = this.price;
        return data;
    }
}

export interface IUpdateGarageServiceCommand {
    id?: string;
    type?: GarageServiceType;
    description?: string;
    durationInMinutes?: number;
    price?: number;
}

export class UpdateGarageEmployeeCommand implements IUpdateGarageEmployeeCommand {
    id?: string;
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItemDto[];
    workExperiences?: GarageEmployeeWorkExperienceItemDto[];

    constructor(data?: IUpdateGarageEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
            this.contact = _data["contact"] ? GarageEmployeeContactItem.fromJS(_data["contact"]) : <any>undefined;
            if (Array.isArray(_data["workSchema"])) {
                this.workSchema = [] as any;
                for (let item of _data["workSchema"])
                    this.workSchema!.push(GarageEmployeeWorkSchemaItemDto.fromJS(item));
            }
            if (Array.isArray(_data["workExperiences"])) {
                this.workExperiences = [] as any;
                for (let item of _data["workExperiences"])
                    this.workExperiences!.push(GarageEmployeeWorkExperienceItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateGarageEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGarageEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.workSchema)) {
            data["workSchema"] = [];
            for (let item of this.workSchema)
                data["workSchema"].push(item.toJSON());
        }
        if (Array.isArray(this.workExperiences)) {
            data["workExperiences"] = [];
            for (let item of this.workExperiences)
                data["workExperiences"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateGarageEmployeeCommand {
    id?: string;
    isActive?: boolean;
    contact?: GarageEmployeeContactItem;
    workSchema?: GarageEmployeeWorkSchemaItemDto[];
    workExperiences?: GarageEmployeeWorkExperienceItemDto[];
}

export class PaginatedListOfGarageLookupBriefDto implements IPaginatedListOfGarageLookupBriefDto {
    items?: GarageLookupBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfGarageLookupBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GarageLookupBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfGarageLookupBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfGarageLookupBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfGarageLookupBriefDto {
    items?: GarageLookupBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GarageLookupBriefDto implements IGarageLookupBriefDto {
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    address?: string;
    city?: string;
    website?: string | undefined;
    daysOfWeek?: number[];
    knownServices?: GarageServiceType[];
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    distanceInMeter?: number;
    hasPickupService?: boolean;
    hasReplacementTransportService?: boolean;

    constructor(data?: IGarageLookupBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.garageId = _data["garageId"];
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.website = _data["website"];
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(item);
            }
            if (Array.isArray(_data["knownServices"])) {
                this.knownServices = [] as any;
                for (let item of _data["knownServices"])
                    this.knownServices!.push(item);
            }
            this.rating = _data["rating"];
            this.userRatingsTotal = _data["userRatingsTotal"];
            this.distanceInMeter = _data["distanceInMeter"];
            this.hasPickupService = _data["hasPickupService"];
            this.hasReplacementTransportService = _data["hasReplacementTransportService"];
        }
    }

    static fromJS(data: any): GarageLookupBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garageId"] = this.garageId;
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["website"] = this.website;
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item);
        }
        if (Array.isArray(this.knownServices)) {
            data["knownServices"] = [];
            for (let item of this.knownServices)
                data["knownServices"].push(item);
        }
        data["rating"] = this.rating;
        data["userRatingsTotal"] = this.userRatingsTotal;
        data["distanceInMeter"] = this.distanceInMeter;
        data["hasPickupService"] = this.hasPickupService;
        data["hasReplacementTransportService"] = this.hasReplacementTransportService;
        return data;
    }
}

export interface IGarageLookupBriefDto {
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    address?: string;
    city?: string;
    website?: string | undefined;
    daysOfWeek?: number[];
    knownServices?: GarageServiceType[];
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    distanceInMeter?: number;
    hasPickupService?: boolean;
    hasReplacementTransportService?: boolean;
}

export class GarageLookupSimplefiedDto implements IGarageLookupSimplefiedDto {
    identifier?: string;
    name?: string;
    city?: string;

    constructor(data?: IGarageLookupSimplefiedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): GarageLookupSimplefiedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupSimplefiedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["city"] = this.city;
        return data;
    }
}

export interface IGarageLookupSimplefiedDto {
    identifier?: string;
    name?: string;
    city?: string;
}

export class GarageLookupDto implements IGarageLookupDto {
    id?: string;
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    image?: string;
    imageThumbnail?: string;
    knownServices?: GarageServiceType[];
    daysOfWeek?: number[];
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    website?: string | undefined;
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    address?: string;
    city?: string;
    conversationContactIdentifier?: string | undefined;
    conversationContactType?: ContactType | undefined;
    hasPickupService?: boolean;
    hasReplacementTransportService?: boolean;

    constructor(data?: IGarageLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.garageId = _data["garageId"];
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.imageThumbnail = _data["imageThumbnail"];
            if (Array.isArray(_data["knownServices"])) {
                this.knownServices = [] as any;
                for (let item of _data["knownServices"])
                    this.knownServices!.push(item);
            }
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.whatsappNumber = _data["whatsappNumber"];
            this.emailAddress = _data["emailAddress"];
            this.website = _data["website"];
            this.rating = _data["rating"];
            this.userRatingsTotal = _data["userRatingsTotal"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.conversationContactIdentifier = _data["conversationContactIdentifier"];
            this.conversationContactType = _data["conversationContactType"];
            this.hasPickupService = _data["hasPickupService"];
            this.hasReplacementTransportService = _data["hasReplacementTransportService"];
        }
    }

    static fromJS(data: any): GarageLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["garageId"] = this.garageId;
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        if (Array.isArray(this.knownServices)) {
            data["knownServices"] = [];
            for (let item of this.knownServices)
                data["knownServices"].push(item);
        }
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["whatsappNumber"] = this.whatsappNumber;
        data["emailAddress"] = this.emailAddress;
        data["website"] = this.website;
        data["rating"] = this.rating;
        data["userRatingsTotal"] = this.userRatingsTotal;
        data["address"] = this.address;
        data["city"] = this.city;
        data["conversationContactIdentifier"] = this.conversationContactIdentifier;
        data["conversationContactType"] = this.conversationContactType;
        data["hasPickupService"] = this.hasPickupService;
        data["hasReplacementTransportService"] = this.hasReplacementTransportService;
        return data;
    }
}

export interface IGarageLookupDto {
    id?: string;
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    image?: string;
    imageThumbnail?: string;
    knownServices?: GarageServiceType[];
    daysOfWeek?: number[];
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    website?: string | undefined;
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    address?: string;
    city?: string;
    conversationContactIdentifier?: string | undefined;
    conversationContactType?: ContactType | undefined;
    hasPickupService?: boolean;
    hasReplacementTransportService?: boolean;
}

export class GarageLookupsStatusDto implements IGarageLookupsStatusDto {
    ableToInsert?: number;
    ableToUpdate?: number;
    upToDate?: number;
    total?: number;

    constructor(data?: IGarageLookupsStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ableToInsert = _data["ableToInsert"];
            this.ableToUpdate = _data["ableToUpdate"];
            this.upToDate = _data["upToDate"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GarageLookupsStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupsStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ableToInsert"] = this.ableToInsert;
        data["ableToUpdate"] = this.ableToUpdate;
        data["upToDate"] = this.upToDate;
        data["total"] = this.total;
        return data;
    }
}

export interface IGarageLookupsStatusDto {
    ableToInsert?: number;
    ableToUpdate?: number;
    upToDate?: number;
    total?: number;
}

export class VehicleSpecificationsCardItem implements IVehicleSpecificationsCardItem {
    licensePlate?: string;
    type?: VehicleLookupType;
    brand?: string;
    consumption?: string;
    mileage?: string;
    dateOfMOTExpiry?: Date | undefined;
    dateOfAscription?: Date | undefined;

    constructor(data?: IVehicleSpecificationsCardItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.licensePlate = _data["licensePlate"];
            this.type = _data["type"];
            this.brand = _data["brand"];
            this.consumption = _data["consumption"];
            this.mileage = _data["mileage"];
            this.dateOfMOTExpiry = _data["dateOfMOTExpiry"] ? new Date(_data["dateOfMOTExpiry"].toString()) : <any>undefined;
            this.dateOfAscription = _data["dateOfAscription"] ? new Date(_data["dateOfAscription"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleSpecificationsCardItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleSpecificationsCardItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licensePlate"] = this.licensePlate;
        data["type"] = this.type;
        data["brand"] = this.brand;
        data["consumption"] = this.consumption;
        data["mileage"] = this.mileage;
        data["dateOfMOTExpiry"] = this.dateOfMOTExpiry ? this.dateOfMOTExpiry.toISOString() : <any>undefined;
        data["dateOfAscription"] = this.dateOfAscription ? this.dateOfAscription.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVehicleSpecificationsCardItem {
    licensePlate?: string;
    type?: VehicleLookupType;
    brand?: string;
    consumption?: string;
    mileage?: string;
    dateOfMOTExpiry?: Date | undefined;
    dateOfAscription?: Date | undefined;
}

export enum VehicleLookupType {
    Other = 0,
    LightCar = 1,
    HeavyCar = 2,
    Taxi = 3,
    Bus = 4,
    Truck = 5,
    Motorcycle = 6,
    Tractor = 7,
    Trailer = 8,
    Caravan = 9,
}

export class VehicleSpecificationsDtoItem implements IVehicleSpecificationsDtoItem {
    data?: VehicleInfoSectionItem[];

    constructor(data?: IVehicleSpecificationsDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(VehicleInfoSectionItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleSpecificationsDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleSpecificationsDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleSpecificationsDtoItem {
    data?: VehicleInfoSectionItem[];
}

export class VehicleInfoSectionItem implements IVehicleInfoSectionItem {
    title?: string;
    values?: string[][];

    constructor(data?: IVehicleInfoSectionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): VehicleInfoSectionItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInfoSectionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IVehicleInfoSectionItem {
    title?: string;
    values?: string[][];
}

export class VehicleServiceLogDtoItem implements IVehicleServiceLogDtoItem {
    garageLookupName?: string;
    garageLookupIdentifier?: string;
    type?: GarageServiceType;
    date?: Date;
    odometerReading?: number;
    description?: string | undefined;
    attachedFile?: string | undefined;

    constructor(data?: IVehicleServiceLogDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.garageLookupName = _data["garageLookupName"];
            this.garageLookupIdentifier = _data["garageLookupIdentifier"];
            this.type = _data["type"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.odometerReading = _data["odometerReading"];
            this.description = _data["description"];
            this.attachedFile = _data["attachedFile"];
        }
    }

    static fromJS(data: any): VehicleServiceLogDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleServiceLogDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garageLookupName"] = this.garageLookupName;
        data["garageLookupIdentifier"] = this.garageLookupIdentifier;
        data["type"] = this.type;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["odometerReading"] = this.odometerReading;
        data["description"] = this.description;
        data["attachedFile"] = this.attachedFile;
        return data;
    }
}

export interface IVehicleServiceLogDtoItem {
    garageLookupName?: string;
    garageLookupIdentifier?: string;
    type?: GarageServiceType;
    date?: Date;
    odometerReading?: number;
    description?: string | undefined;
    attachedFile?: string | undefined;
}

export class VehicleTimelineDtoItem implements IVehicleTimelineDtoItem {
    title?: string;
    description?: string;
    date?: Date;
    type?: VehicleTimelineType;
    extraData?: TupleOfStringAndString[];

    constructor(data?: IVehicleTimelineDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            if (Array.isArray(_data["extraData"])) {
                this.extraData = [] as any;
                for (let item of _data["extraData"])
                    this.extraData!.push(TupleOfStringAndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleTimelineDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTimelineDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.extraData)) {
            data["extraData"] = [];
            for (let item of this.extraData)
                data["extraData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleTimelineDtoItem {
    title?: string;
    description?: string;
    date?: Date;
    type?: VehicleTimelineType;
    extraData?: TupleOfStringAndString[];
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}