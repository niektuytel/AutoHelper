//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IAdminAccountClient {

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) 
     * @param maxInsertAmount (optional) -1 is all of them
     * @param maxUpdateAmount (optional) -1 is all of them
     * @param batchSize (optional) 
     */
    syncGarageLookups(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string>;

    syncVehicleLookup(licensePlate: string | null | undefined): Promise<string>;

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    syncVehicleLookups(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string>;

    syncVehicleTimeline(licensePlate: string | null | undefined): Promise<string>;

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    syncVehicleTimelines(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string>;
}

export class AdminAccountClient implements IAdminAccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) 
     * @param maxInsertAmount (optional) -1 is all of them
     * @param maxUpdateAmount (optional) -1 is all of them
     * @param batchSize (optional) 
     */
    syncGarageLookups(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AdminAccount/SyncGarageLookups?";
        if (startRowIndex === null)
            throw new Error("The parameter 'startRowIndex' cannot be null.");
        else if (startRowIndex !== undefined)
            url_ += "startRowIndex=" + encodeURIComponent("" + startRowIndex) + "&";
        if (endRowIndex === null)
            throw new Error("The parameter 'endRowIndex' cannot be null.");
        else if (endRowIndex !== undefined)
            url_ += "endRowIndex=" + encodeURIComponent("" + endRowIndex) + "&";
        if (maxInsertAmount === null)
            throw new Error("The parameter 'maxInsertAmount' cannot be null.");
        else if (maxInsertAmount !== undefined)
            url_ += "maxInsertAmount=" + encodeURIComponent("" + maxInsertAmount) + "&";
        if (maxUpdateAmount === null)
            throw new Error("The parameter 'maxUpdateAmount' cannot be null.");
        else if (maxUpdateAmount !== undefined)
            url_ += "maxUpdateAmount=" + encodeURIComponent("" + maxUpdateAmount) + "&";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncGarageLookups(_response);
        });
    }

    protected processSyncGarageLookups(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    syncVehicleLookup(licensePlate: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AdminAccount/SyncVehicleLookup?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncVehicleLookup(_response);
        });
    }

    protected processSyncVehicleLookup(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    syncVehicleLookups(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AdminAccount/SyncVehicleLookups?";
        if (startRowIndex === null)
            throw new Error("The parameter 'startRowIndex' cannot be null.");
        else if (startRowIndex !== undefined)
            url_ += "startRowIndex=" + encodeURIComponent("" + startRowIndex) + "&";
        if (endRowIndex === null)
            throw new Error("The parameter 'endRowIndex' cannot be null.");
        else if (endRowIndex !== undefined)
            url_ += "endRowIndex=" + encodeURIComponent("" + endRowIndex) + "&";
        if (maxInsertAmount === null)
            throw new Error("The parameter 'maxInsertAmount' cannot be null.");
        else if (maxInsertAmount !== undefined)
            url_ += "maxInsertAmount=" + encodeURIComponent("" + maxInsertAmount) + "&";
        if (maxUpdateAmount === null)
            throw new Error("The parameter 'maxUpdateAmount' cannot be null.");
        else if (maxUpdateAmount !== undefined)
            url_ += "maxUpdateAmount=" + encodeURIComponent("" + maxUpdateAmount) + "&";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncVehicleLookups(_response);
        });
    }

    protected processSyncVehicleLookups(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    syncVehicleTimeline(licensePlate: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AdminAccount/SyncVehicleTimeline?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncVehicleTimeline(_response);
        });
    }

    protected processSyncVehicleTimeline(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param startRowIndex (optional) 
     * @param endRowIndex (optional) -1 means all of them
     * @param maxInsertAmount (optional) -1 means all of them
     * @param maxUpdateAmount (optional) -1 means all of them
     * @param batchSize (optional) 
     */
    syncVehicleTimelines(startRowIndex: number | undefined, endRowIndex: number | undefined, maxInsertAmount: number | undefined, maxUpdateAmount: number | undefined, batchSize: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AdminAccount/SyncVehicleTimelines?";
        if (startRowIndex === null)
            throw new Error("The parameter 'startRowIndex' cannot be null.");
        else if (startRowIndex !== undefined)
            url_ += "startRowIndex=" + encodeURIComponent("" + startRowIndex) + "&";
        if (endRowIndex === null)
            throw new Error("The parameter 'endRowIndex' cannot be null.");
        else if (endRowIndex !== undefined)
            url_ += "endRowIndex=" + encodeURIComponent("" + endRowIndex) + "&";
        if (maxInsertAmount === null)
            throw new Error("The parameter 'maxInsertAmount' cannot be null.");
        else if (maxInsertAmount !== undefined)
            url_ += "maxInsertAmount=" + encodeURIComponent("" + maxInsertAmount) + "&";
        if (maxUpdateAmount === null)
            throw new Error("The parameter 'maxUpdateAmount' cannot be null.");
        else if (maxUpdateAmount !== undefined)
            url_ += "maxUpdateAmount=" + encodeURIComponent("" + maxUpdateAmount) + "&";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncVehicleTimelines(_response);
        });
    }

    protected processSyncVehicleTimelines(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IConversationClient {

    startGarageConversation(command: CreateGarageConversationItemsCommand): Promise<void>;

    receiveEmailMessage(message: ReceiveEmailMessageCommand): Promise<string>;
}

export class ConversationClient implements IConversationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    startGarageConversation(command: CreateGarageConversationItemsCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/Conversation/StartGarageConversation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGarageConversation(_response);
        });
    }

    protected processStartGarageConversation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    receiveEmailMessage(message: ReceiveEmailMessageCommand): Promise<string> {
        let url_ = this.baseUrl + "/api/Conversation/ReceiveEmailMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReceiveEmailMessage(_response);
        });
    }

    protected processReceiveEmailMessage(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IGarageAccountClient {

    getSettings(): Promise<GarageSettingsDtoItem>;

    getServices(licensePlate: string | null | undefined): Promise<GarageServiceDtoItem[]>;

    getServiceLogs(licensePlate: string | null | undefined): Promise<VehicleServiceLogAsGarageDtoItem[]>;

    getOverview(): Promise<GarageOverviewDtoItem>;

    createGarage(command: CreateGarageCommand): Promise<GarageSettingsDtoItem>;

    createService(command: CreateGarageServiceCommand): Promise<GarageServiceDtoItem>;

    createServiceLog(vehicleLicensePlate: string | undefined, garageServiceId: string | null | undefined, description: string | null | undefined, date: string | undefined, expectedNextDate: string | null | undefined, odometerReading: number | undefined, expectedNextOdometerReading: number | null | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogAsGarageDtoItem>;

    updateSettings(command: UpdateGarageSettingsCommand): Promise<GarageSettingsDtoItem>;

    updateService(command: UpdateGarageServiceCommand): Promise<GarageServiceDtoItem>;

    updateServiceLog(id: string | undefined, vehicleLicensePlate: string | undefined, garageServiceId: string | undefined, description: string | null | undefined, date: string | undefined, expectedNextDate: string | null | undefined, odometerReading: number | undefined, expectedNextOdometerReading: number | null | undefined, status: VehicleServiceLogStatus | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogAsGarageDtoItem>;

    deleteService(id: string): Promise<GarageServiceDtoItem>;

    deleteServiceLog(id: string): Promise<VehicleServiceLogAsGarageDtoItem>;
}

export class GarageAccountClient implements IGarageAccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSettings(): Promise<GarageSettingsDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<GarageSettingsDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageSettingsDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageSettingsDtoItem>(null as any);
    }

    getServices(licensePlate: string | null | undefined): Promise<GarageServiceDtoItem[]> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetServices?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServices(_response);
        });
    }

    protected processGetServices(response: Response): Promise<GarageServiceDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageServiceDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceDtoItem[]>(null as any);
    }

    getServiceLogs(licensePlate: string | null | undefined): Promise<VehicleServiceLogAsGarageDtoItem[]> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetServiceLogs?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceLogs(_response);
        });
    }

    protected processGetServiceLogs(response: Response): Promise<VehicleServiceLogAsGarageDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleServiceLogAsGarageDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogAsGarageDtoItem[]>(null as any);
    }

    getOverview(): Promise<GarageOverviewDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/GetOverview";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOverview(_response);
        });
    }

    protected processGetOverview(response: Response): Promise<GarageOverviewDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageOverviewDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageOverviewDtoItem>(null as any);
    }

    createGarage(command: CreateGarageCommand): Promise<GarageSettingsDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/CreateGarage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGarage(_response);
        });
    }

    protected processCreateGarage(response: Response): Promise<GarageSettingsDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageSettingsDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageSettingsDtoItem>(null as any);
    }

    createService(command: CreateGarageServiceCommand): Promise<GarageServiceDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/CreateService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateService(_response);
        });
    }

    protected processCreateService(response: Response): Promise<GarageServiceDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageServiceDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceDtoItem>(null as any);
    }

    createServiceLog(vehicleLicensePlate: string | undefined, garageServiceId: string | null | undefined, description: string | null | undefined, date: string | undefined, expectedNextDate: string | null | undefined, odometerReading: number | undefined, expectedNextOdometerReading: number | null | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogAsGarageDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/CreateServiceLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (vehicleLicensePlate === null || vehicleLicensePlate === undefined)
            throw new Error("The parameter 'vehicleLicensePlate' cannot be null.");
        else
            content_.append("VehicleLicensePlate", vehicleLicensePlate.toString());
        if (garageServiceId !== null && garageServiceId !== undefined)
            content_.append("GarageServiceId", garageServiceId.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (date === null || date === undefined)
            throw new Error("The parameter 'date' cannot be null.");
        else
            content_.append("Date", date.toString());
        if (expectedNextDate !== null && expectedNextDate !== undefined)
            content_.append("ExpectedNextDate", expectedNextDate.toString());
        if (odometerReading === null || odometerReading === undefined)
            throw new Error("The parameter 'odometerReading' cannot be null.");
        else
            content_.append("OdometerReading", odometerReading.toString());
        if (expectedNextOdometerReading !== null && expectedNextOdometerReading !== undefined)
            content_.append("ExpectedNextOdometerReading", expectedNextOdometerReading.toString());
        if (attachmentFile !== null && attachmentFile !== undefined)
            content_.append("AttachmentFile", attachmentFile.data, attachmentFile.fileName ? attachmentFile.fileName : "AttachmentFile");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServiceLog(_response);
        });
    }

    protected processCreateServiceLog(response: Response): Promise<VehicleServiceLogAsGarageDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleServiceLogAsGarageDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogAsGarageDtoItem>(null as any);
    }

    updateSettings(command: UpdateGarageSettingsCommand): Promise<GarageSettingsDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/UpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSettings(_response);
        });
    }

    protected processUpdateSettings(response: Response): Promise<GarageSettingsDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageSettingsDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageSettingsDtoItem>(null as any);
    }

    updateService(command: UpdateGarageServiceCommand): Promise<GarageServiceDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/UpdateService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateService(_response);
        });
    }

    protected processUpdateService(response: Response): Promise<GarageServiceDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageServiceDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceDtoItem>(null as any);
    }

    updateServiceLog(id: string | undefined, vehicleLicensePlate: string | undefined, garageServiceId: string | undefined, description: string | null | undefined, date: string | undefined, expectedNextDate: string | null | undefined, odometerReading: number | undefined, expectedNextOdometerReading: number | null | undefined, status: VehicleServiceLogStatus | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogAsGarageDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/UpdateServiceLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (vehicleLicensePlate === null || vehicleLicensePlate === undefined)
            throw new Error("The parameter 'vehicleLicensePlate' cannot be null.");
        else
            content_.append("VehicleLicensePlate", vehicleLicensePlate.toString());
        if (garageServiceId === null || garageServiceId === undefined)
            throw new Error("The parameter 'garageServiceId' cannot be null.");
        else
            content_.append("GarageServiceId", garageServiceId.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (date === null || date === undefined)
            throw new Error("The parameter 'date' cannot be null.");
        else
            content_.append("Date", date.toString());
        if (expectedNextDate !== null && expectedNextDate !== undefined)
            content_.append("ExpectedNextDate", expectedNextDate.toString());
        if (odometerReading === null || odometerReading === undefined)
            throw new Error("The parameter 'odometerReading' cannot be null.");
        else
            content_.append("OdometerReading", odometerReading.toString());
        if (expectedNextOdometerReading !== null && expectedNextOdometerReading !== undefined)
            content_.append("ExpectedNextOdometerReading", expectedNextOdometerReading.toString());
        if (status === null || status === undefined)
            throw new Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (attachmentFile !== null && attachmentFile !== undefined)
            content_.append("AttachmentFile", attachmentFile.data, attachmentFile.fileName ? attachmentFile.fileName : "AttachmentFile");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateServiceLog(_response);
        });
    }

    protected processUpdateServiceLog(response: Response): Promise<VehicleServiceLogAsGarageDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleServiceLogAsGarageDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogAsGarageDtoItem>(null as any);
    }

    deleteService(id: string): Promise<GarageServiceDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/DeleteService/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteService(_response);
        });
    }

    protected processDeleteService(response: Response): Promise<GarageServiceDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageServiceDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceDtoItem>(null as any);
    }

    deleteServiceLog(id: string): Promise<VehicleServiceLogAsGarageDtoItem> {
        let url_ = this.baseUrl + "/api/GarageAccount/DeleteServiceLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServiceLog(_response);
        });
    }

    protected processDeleteServiceLog(response: Response): Promise<VehicleServiceLogAsGarageDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleServiceLogAsGarageDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogAsGarageDtoItem>(null as any);
    }
}

export interface IGarageClient {

    searchLookups(licensePlate: string | null, latitude: number, longitude: number, inMetersRange: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, autoCompleteOnGarageName: string | null | undefined, filters: string[] | null | undefined): Promise<PaginatedListOfGarageLookupBriefDto>;

    searchLookupsByName(name: string | null | undefined, maxSize: number | undefined): Promise<GarageLookupDtoItem[]>;

    searchLookupCardsByName(name: string | null | undefined, maxSize: number | undefined): Promise<GarageLookupSimplefiedDto[]>;

    getLookup(identifier: string | null, licensePlate: string | null | undefined): Promise<GarageLookupDtoItem>;

    getServices(identifier: string | null, licensePlate: string | null | undefined): Promise<GarageServiceDtoItem[]>;
}

export class GarageClient implements IGarageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    searchLookups(licensePlate: string | null, latitude: number, longitude: number, inMetersRange: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, autoCompleteOnGarageName: string | null | undefined, filters: string[] | null | undefined): Promise<PaginatedListOfGarageLookupBriefDto> {
        let url_ = this.baseUrl + "/api/Garage/SearchLookups/{licensePlate}/{latitude}/{longitude}?";
        if (licensePlate === undefined || licensePlate === null)
            throw new Error("The parameter 'licensePlate' must be defined.");
        url_ = url_.replace("{licensePlate}", encodeURIComponent("" + licensePlate));
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined.");
        url_ = url_.replace("{latitude}", encodeURIComponent("" + latitude));
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined.");
        url_ = url_.replace("{longitude}", encodeURIComponent("" + longitude));
        if (inMetersRange === null)
            throw new Error("The parameter 'inMetersRange' cannot be null.");
        else if (inMetersRange !== undefined)
            url_ += "inMetersRange=" + encodeURIComponent("" + inMetersRange) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (autoCompleteOnGarageName !== undefined && autoCompleteOnGarageName !== null)
            url_ += "autoCompleteOnGarageName=" + encodeURIComponent("" + autoCompleteOnGarageName) + "&";
        if (filters !== undefined && filters !== null)
            filters && filters.forEach(item => { url_ += "filters=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchLookups(_response);
        });
    }

    protected processSearchLookups(response: Response): Promise<PaginatedListOfGarageLookupBriefDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfGarageLookupBriefDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfGarageLookupBriefDto>(null as any);
    }

    searchLookupsByName(name: string | null | undefined, maxSize: number | undefined): Promise<GarageLookupDtoItem[]> {
        let url_ = this.baseUrl + "/api/Garage/SearchLookupsByName?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (maxSize === null)
            throw new Error("The parameter 'maxSize' cannot be null.");
        else if (maxSize !== undefined)
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchLookupsByName(_response);
        });
    }

    protected processSearchLookupsByName(response: Response): Promise<GarageLookupDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageLookupDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageLookupDtoItem[]>(null as any);
    }

    searchLookupCardsByName(name: string | null | undefined, maxSize: number | undefined): Promise<GarageLookupSimplefiedDto[]> {
        let url_ = this.baseUrl + "/api/Garage/SearchLookupCardsByName?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (maxSize === null)
            throw new Error("The parameter 'maxSize' cannot be null.");
        else if (maxSize !== undefined)
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchLookupCardsByName(_response);
        });
    }

    protected processSearchLookupCardsByName(response: Response): Promise<GarageLookupSimplefiedDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageLookupSimplefiedDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageLookupSimplefiedDto[]>(null as any);
    }

    getLookup(identifier: string | null, licensePlate: string | null | undefined): Promise<GarageLookupDtoItem> {
        let url_ = this.baseUrl + "/api/Garage/GetLookup/{identifier}?";
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier));
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLookup(_response);
        });
    }

    protected processGetLookup(response: Response): Promise<GarageLookupDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarageLookupDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageLookupDtoItem>(null as any);
    }

    getServices(identifier: string | null, licensePlate: string | null | undefined): Promise<GarageServiceDtoItem[]> {
        let url_ = this.baseUrl + "/api/Garage/GetServices/{identifier}?";
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier));
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServices(_response);
        });
    }

    protected processGetServices(response: Response): Promise<GarageServiceDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GarageServiceDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GarageServiceDtoItem[]>(null as any);
    }
}

export interface IVehicleClient {

    getSpecificationsCard(licensePlate: string | null | undefined): Promise<VehicleSpecificationsCardItem>;

    getSpecifications(licensePlate: string | null | undefined): Promise<VehicleSpecificationsDtoItem>;

    getServiceLogs(licensePlate: string | null | undefined): Promise<VehicleServiceLogDtoItem[]>;

    /**
     * @param licensePlate (optional) 
     * @param maxAmount (optional) -1 means all of them
     */
    getTimeline(licensePlate: string | null | undefined, maxAmount: number | undefined): Promise<VehicleTimelineDtoItem[]>;

    createServiceLog(vehicleLicensePlate: string | null | undefined, garageLookupIdentifier: string | null | undefined, garageServiceId: string | null | undefined, description: string | null | undefined, date: string | null | undefined, expectedNextDate: string | null | undefined, odometerReading: number | undefined, expectedNextOdometerReading: number | null | undefined, reporterName: string | null | undefined, reporterPhoneNumber: string | null | undefined, reporterEmailAddress: string | null | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogDtoItem>;
}

export class VehicleClient implements IVehicleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSpecificationsCard(licensePlate: string | null | undefined): Promise<VehicleSpecificationsCardItem> {
        let url_ = this.baseUrl + "/api/Vehicle/GetSpecificationsCard?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpecificationsCard(_response);
        });
    }

    protected processGetSpecificationsCard(response: Response): Promise<VehicleSpecificationsCardItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleSpecificationsCardItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleSpecificationsCardItem>(null as any);
    }

    getSpecifications(licensePlate: string | null | undefined): Promise<VehicleSpecificationsDtoItem> {
        let url_ = this.baseUrl + "/api/Vehicle/GetSpecifications?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpecifications(_response);
        });
    }

    protected processGetSpecifications(response: Response): Promise<VehicleSpecificationsDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleSpecificationsDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleSpecificationsDtoItem>(null as any);
    }

    getServiceLogs(licensePlate: string | null | undefined): Promise<VehicleServiceLogDtoItem[]> {
        let url_ = this.baseUrl + "/api/Vehicle/GetServiceLogs?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceLogs(_response);
        });
    }

    protected processGetServiceLogs(response: Response): Promise<VehicleServiceLogDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleServiceLogDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogDtoItem[]>(null as any);
    }

    /**
     * @param licensePlate (optional) 
     * @param maxAmount (optional) -1 means all of them
     */
    getTimeline(licensePlate: string | null | undefined, maxAmount: number | undefined): Promise<VehicleTimelineDtoItem[]> {
        let url_ = this.baseUrl + "/api/Vehicle/GetTimeline?";
        if (licensePlate !== undefined && licensePlate !== null)
            url_ += "licensePlate=" + encodeURIComponent("" + licensePlate) + "&";
        if (maxAmount === null)
            throw new Error("The parameter 'maxAmount' cannot be null.");
        else if (maxAmount !== undefined)
            url_ += "maxAmount=" + encodeURIComponent("" + maxAmount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimeline(_response);
        });
    }

    protected processGetTimeline(response: Response): Promise<VehicleTimelineDtoItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleTimelineDtoItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleTimelineDtoItem[]>(null as any);
    }

    createServiceLog(vehicleLicensePlate: string | null | undefined, garageLookupIdentifier: string | null | undefined, garageServiceId: string | null | undefined, description: string | null | undefined, date: string | null | undefined, expectedNextDate: string | null | undefined, odometerReading: number | undefined, expectedNextOdometerReading: number | null | undefined, reporterName: string | null | undefined, reporterPhoneNumber: string | null | undefined, reporterEmailAddress: string | null | undefined, attachmentFile: FileParameter | null | undefined): Promise<VehicleServiceLogDtoItem> {
        let url_ = this.baseUrl + "/api/Vehicle/CreateServiceLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (vehicleLicensePlate !== null && vehicleLicensePlate !== undefined)
            content_.append("VehicleLicensePlate", vehicleLicensePlate.toString());
        if (garageLookupIdentifier !== null && garageLookupIdentifier !== undefined)
            content_.append("GarageLookupIdentifier", garageLookupIdentifier.toString());
        if (garageServiceId !== null && garageServiceId !== undefined)
            content_.append("GarageServiceId", garageServiceId.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (date !== null && date !== undefined)
            content_.append("Date", date.toString());
        if (expectedNextDate !== null && expectedNextDate !== undefined)
            content_.append("ExpectedNextDate", expectedNextDate.toString());
        if (odometerReading === null || odometerReading === undefined)
            throw new Error("The parameter 'odometerReading' cannot be null.");
        else
            content_.append("OdometerReading", odometerReading.toString());
        if (expectedNextOdometerReading !== null && expectedNextOdometerReading !== undefined)
            content_.append("ExpectedNextOdometerReading", expectedNextOdometerReading.toString());
        if (reporterName !== null && reporterName !== undefined)
            content_.append("ReporterName", reporterName.toString());
        if (reporterPhoneNumber !== null && reporterPhoneNumber !== undefined)
            content_.append("ReporterPhoneNumber", reporterPhoneNumber.toString());
        if (reporterEmailAddress !== null && reporterEmailAddress !== undefined)
            content_.append("ReporterEmailAddress", reporterEmailAddress.toString());
        if (attachmentFile !== null && attachmentFile !== undefined)
            content_.append("AttachmentFile", attachmentFile.data, attachmentFile.fileName ? attachmentFile.fileName : "AttachmentFile");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServiceLog(_response);
        });
    }

    protected processCreateServiceLog(response: Response): Promise<VehicleServiceLogDtoItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleServiceLogDtoItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BadRequestResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleServiceLogDtoItem>(null as any);
    }
}

export interface IWebhookClient {

    configureWhatsAppMessageWebhook(hubMode: string | null | undefined, hubChallenge: number | undefined, hubVerifyToken: string | null | undefined): Promise<string>;

    receiveWhatsAppTextMessage(messageReceived: any): Promise<FileResponse>;
}

export class WebhookClient implements IWebhookClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    configureWhatsAppMessageWebhook(hubMode: string | null | undefined, hubChallenge: number | undefined, hubVerifyToken: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Webhook/ConfigureWhatsAppMessageWebhook?";
        if (hubMode !== undefined && hubMode !== null)
            url_ += "hub.mode=" + encodeURIComponent("" + hubMode) + "&";
        if (hubChallenge === null)
            throw new Error("The parameter 'hubChallenge' cannot be null.");
        else if (hubChallenge !== undefined)
            url_ += "hub.challenge=" + encodeURIComponent("" + hubChallenge) + "&";
        if (hubVerifyToken !== undefined && hubVerifyToken !== null)
            url_ += "hub.verify_token=" + encodeURIComponent("" + hubVerifyToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigureWhatsAppMessageWebhook(_response);
        });
    }

    protected processConfigureWhatsAppMessageWebhook(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    receiveWhatsAppTextMessage(messageReceived: any): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Webhook/ReceiveWhatsAppTextMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(messageReceived);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReceiveWhatsAppTextMessage(_response);
        });
    }

    protected processReceiveWhatsAppTextMessage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class BadRequestResponse implements IBadRequestResponse {
    type?: string;
    title?: string;
    status?: number;
    errors?: { [key: string]: string; };

    constructor(data?: IBadRequestResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
        }
    }

    static fromJS(data: any): BadRequestResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BadRequestResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IBadRequestResponse {
    type?: string;
    title?: string;
    status?: number;
    errors?: { [key: string]: string; };
}

export class CreateGarageConversationItemsCommand implements ICreateGarageConversationItemsCommand {
    userWhatsappNumber?: string | undefined;
    userEmailAddress?: string | undefined;
    messageType?: ConversationType;
    messageContent!: string;
    services!: VehicleService[];

    constructor(data?: ICreateGarageConversationItemsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.services = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userWhatsappNumber = _data["userWhatsappNumber"];
            this.userEmailAddress = _data["userEmailAddress"];
            this.messageType = _data["messageType"];
            this.messageContent = _data["messageContent"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(VehicleService.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateGarageConversationItemsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGarageConversationItemsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userWhatsappNumber"] = this.userWhatsappNumber;
        data["userEmailAddress"] = this.userEmailAddress;
        data["messageType"] = this.messageType;
        data["messageContent"] = this.messageContent;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateGarageConversationItemsCommand {
    userWhatsappNumber?: string | undefined;
    userEmailAddress?: string | undefined;
    messageType?: ConversationType;
    messageContent: string;
    services: VehicleService[];
}

export enum ConversationType {
    Other = 0,
    Price = 1,
    Appointment = 2,
    Technical = 3,
    RequestAQuote = 4,
}

export class VehicleService implements IVehicleService {
    garageServiceId!: string;
    garageServiceTitle?: string | undefined;
    relatedGarageLookupIdentifier!: string;
    relatedGarageLookupName!: string;
    conversationEmailAddress?: string | undefined;
    conversationWhatsappNumber?: string | undefined;
    vehicleLicensePlate!: string;
    vehicleLongitude!: string;
    vehicleLatitude!: string;

    constructor(data?: IVehicleService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.garageServiceId = _data["garageServiceId"];
            this.garageServiceTitle = _data["garageServiceTitle"];
            this.relatedGarageLookupIdentifier = _data["relatedGarageLookupIdentifier"];
            this.relatedGarageLookupName = _data["relatedGarageLookupName"];
            this.conversationEmailAddress = _data["conversationEmailAddress"];
            this.conversationWhatsappNumber = _data["conversationWhatsappNumber"];
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.vehicleLongitude = _data["vehicleLongitude"];
            this.vehicleLatitude = _data["vehicleLatitude"];
        }
    }

    static fromJS(data: any): VehicleService {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garageServiceId"] = this.garageServiceId;
        data["garageServiceTitle"] = this.garageServiceTitle;
        data["relatedGarageLookupIdentifier"] = this.relatedGarageLookupIdentifier;
        data["relatedGarageLookupName"] = this.relatedGarageLookupName;
        data["conversationEmailAddress"] = this.conversationEmailAddress;
        data["conversationWhatsappNumber"] = this.conversationWhatsappNumber;
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["vehicleLongitude"] = this.vehicleLongitude;
        data["vehicleLatitude"] = this.vehicleLatitude;
        return data;
    }
}

export interface IVehicleService {
    garageServiceId: string;
    garageServiceTitle?: string | undefined;
    relatedGarageLookupIdentifier: string;
    relatedGarageLookupName: string;
    conversationEmailAddress?: string | undefined;
    conversationWhatsappNumber?: string | undefined;
    vehicleLicensePlate: string;
    vehicleLongitude: string;
    vehicleLatitude: string;
}

export class ReceiveEmailMessageCommand implements IReceiveEmailMessageCommand {
    from?: string;
    subject?: string;
    body?: string;

    constructor(data?: IReceiveEmailMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): ReceiveEmailMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiveEmailMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface IReceiveEmailMessageCommand {
    from?: string;
    subject?: string;
    body?: string;
}

export class GarageSettingsDtoItem implements IGarageSettingsDtoItem {
    name?: string;
    address?: string;
    city?: string;
    image?: string | undefined;
    imageThumbnail?: string | undefined;
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    conversationContactEmail?: string | undefined;
    conversationContactWhatsappNumber?: string | undefined;
    website?: string | undefined;

    constructor(data?: IGarageSettingsDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.image = _data["image"];
            this.imageThumbnail = _data["imageThumbnail"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsappNumber = _data["whatsappNumber"];
            this.emailAddress = _data["emailAddress"];
            this.conversationContactEmail = _data["conversationContactEmail"];
            this.conversationContactWhatsappNumber = _data["conversationContactWhatsappNumber"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): GarageSettingsDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageSettingsDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsappNumber"] = this.whatsappNumber;
        data["emailAddress"] = this.emailAddress;
        data["conversationContactEmail"] = this.conversationContactEmail;
        data["conversationContactWhatsappNumber"] = this.conversationContactWhatsappNumber;
        data["website"] = this.website;
        return data;
    }
}

export interface IGarageSettingsDtoItem {
    name?: string;
    address?: string;
    city?: string;
    image?: string | undefined;
    imageThumbnail?: string | undefined;
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    conversationContactEmail?: string | undefined;
    conversationContactWhatsappNumber?: string | undefined;
    website?: string | undefined;
}

export class GarageServiceDtoItem implements IGarageServiceDtoItem {
    id?: string | undefined;
    type?: GarageServiceType;
    vehicleType?: VehicleType;
    title?: string | undefined;
    description?: string | undefined;
    expectedNextDateIsRequired?: boolean;
    expectedNextOdometerReadingIsRequired?: boolean;

    constructor(data?: IGarageServiceDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.vehicleType = _data["vehicleType"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expectedNextDateIsRequired = _data["expectedNextDateIsRequired"];
            this.expectedNextOdometerReadingIsRequired = _data["expectedNextOdometerReadingIsRequired"];
        }
    }

    static fromJS(data: any): GarageServiceDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageServiceDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["vehicleType"] = this.vehicleType;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expectedNextDateIsRequired"] = this.expectedNextDateIsRequired;
        data["expectedNextOdometerReadingIsRequired"] = this.expectedNextOdometerReadingIsRequired;
        return data;
    }
}

export interface IGarageServiceDtoItem {
    id?: string | undefined;
    type?: GarageServiceType;
    vehicleType?: VehicleType;
    title?: string | undefined;
    description?: string | undefined;
    expectedNextDateIsRequired?: boolean;
    expectedNextOdometerReadingIsRequired?: boolean;
}

export enum GarageServiceType {
    Other = 0,
    Service = 10,
    Repair = 20,
    Inspection = 30,
}

export enum VehicleType {
    Any = 0,
    LightCar = 1,
    HeavyCar = 2,
    Taxi = 3,
    Bus = 4,
    Truck = 5,
    Motorcycle = 6,
    Tractor = 7,
    Trailer = 8,
    Caravan = 9,
}

export class VehicleServiceLogAsGarageDtoItem implements IVehicleServiceLogAsGarageDtoItem {
    id?: string;
    vehicleLicensePlate?: string;
    garageServiceId?: string;
    title?: string | undefined;
    description?: string | undefined;
    attachedFile?: string | undefined;
    notes?: string;
    date?: Date;
    expectedNextDate?: Date | undefined;
    odometerReading?: number;
    expectedNextOdometerReading?: number | undefined;
    status?: VehicleServiceLogStatus;
    metaData?: string;

    constructor(data?: IVehicleServiceLogAsGarageDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleLicensePlate = _data["vehicleLicensePlate"];
            this.garageServiceId = _data["garageServiceId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.attachedFile = _data["attachedFile"];
            this.notes = _data["notes"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.expectedNextDate = _data["expectedNextDate"] ? new Date(_data["expectedNextDate"].toString()) : <any>undefined;
            this.odometerReading = _data["odometerReading"];
            this.expectedNextOdometerReading = _data["expectedNextOdometerReading"];
            this.status = _data["status"];
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): VehicleServiceLogAsGarageDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleServiceLogAsGarageDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleLicensePlate"] = this.vehicleLicensePlate;
        data["garageServiceId"] = this.garageServiceId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["attachedFile"] = this.attachedFile;
        data["notes"] = this.notes;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["expectedNextDate"] = this.expectedNextDate ? this.expectedNextDate.toISOString() : <any>undefined;
        data["odometerReading"] = this.odometerReading;
        data["expectedNextOdometerReading"] = this.expectedNextOdometerReading;
        data["status"] = this.status;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface IVehicleServiceLogAsGarageDtoItem {
    id?: string;
    vehicleLicensePlate?: string;
    garageServiceId?: string;
    title?: string | undefined;
    description?: string | undefined;
    attachedFile?: string | undefined;
    notes?: string;
    date?: Date;
    expectedNextDate?: Date | undefined;
    odometerReading?: number;
    expectedNextOdometerReading?: number | undefined;
    status?: VehicleServiceLogStatus;
    metaData?: string;
}

export enum VehicleServiceLogStatus {
    NotVerified = 0,
    VerifiedByGarage = 1,
}

export class GarageOverviewDtoItem implements IGarageOverviewDtoItem {
    totalApprovedServiceLogs?: number;
    totalPendingServiceLogs?: number;
    totalServedVehicle?: number;
    chartPoints?: ServiceLogsChartPoint[];
    recentServiceLogs?: VehicleServiceLogAsGarageDtoItem[];
    supportedServices?: GarageServiceDtoItem[];

    constructor(data?: IGarageOverviewDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalApprovedServiceLogs = _data["totalApprovedServiceLogs"];
            this.totalPendingServiceLogs = _data["totalPendingServiceLogs"];
            this.totalServedVehicle = _data["totalServedVehicle"];
            if (Array.isArray(_data["chartPoints"])) {
                this.chartPoints = [] as any;
                for (let item of _data["chartPoints"])
                    this.chartPoints!.push(ServiceLogsChartPoint.fromJS(item));
            }
            if (Array.isArray(_data["recentServiceLogs"])) {
                this.recentServiceLogs = [] as any;
                for (let item of _data["recentServiceLogs"])
                    this.recentServiceLogs!.push(VehicleServiceLogAsGarageDtoItem.fromJS(item));
            }
            if (Array.isArray(_data["supportedServices"])) {
                this.supportedServices = [] as any;
                for (let item of _data["supportedServices"])
                    this.supportedServices!.push(GarageServiceDtoItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GarageOverviewDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageOverviewDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalApprovedServiceLogs"] = this.totalApprovedServiceLogs;
        data["totalPendingServiceLogs"] = this.totalPendingServiceLogs;
        data["totalServedVehicle"] = this.totalServedVehicle;
        if (Array.isArray(this.chartPoints)) {
            data["chartPoints"] = [];
            for (let item of this.chartPoints)
                data["chartPoints"].push(item.toJSON());
        }
        if (Array.isArray(this.recentServiceLogs)) {
            data["recentServiceLogs"] = [];
            for (let item of this.recentServiceLogs)
                data["recentServiceLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.supportedServices)) {
            data["supportedServices"] = [];
            for (let item of this.supportedServices)
                data["supportedServices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGarageOverviewDtoItem {
    totalApprovedServiceLogs?: number;
    totalPendingServiceLogs?: number;
    totalServedVehicle?: number;
    chartPoints?: ServiceLogsChartPoint[];
    recentServiceLogs?: VehicleServiceLogAsGarageDtoItem[];
    supportedServices?: GarageServiceDtoItem[];
}

export class ServiceLogsChartPoint implements IServiceLogsChartPoint {
    approvedAmount?: number;
    pendingAmount?: number;
    vehiclesAmount?: number;

    constructor(data?: IServiceLogsChartPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvedAmount = _data["approvedAmount"];
            this.pendingAmount = _data["pendingAmount"];
            this.vehiclesAmount = _data["vehiclesAmount"];
        }
    }

    static fromJS(data: any): ServiceLogsChartPoint {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceLogsChartPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvedAmount"] = this.approvedAmount;
        data["pendingAmount"] = this.pendingAmount;
        data["vehiclesAmount"] = this.vehiclesAmount;
        return data;
    }
}

export interface IServiceLogsChartPoint {
    approvedAmount?: number;
    pendingAmount?: number;
    vehiclesAmount?: number;
}

export class CreateGarageCommand implements ICreateGarageCommand {
    garageLookupIdentifier!: string;
    website?: string | undefined;
    phoneNumber!: string;
    whatsappNumber?: string | undefined;
    emailAddress!: string;
    conversationEmail?: string | undefined;
    conversationWhatsappNumber?: string | undefined;
    location?: GarageLocationDtoItem;

    constructor(data?: ICreateGarageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.garageLookupIdentifier = _data["garageLookupIdentifier"];
            this.website = _data["website"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsappNumber = _data["whatsappNumber"];
            this.emailAddress = _data["emailAddress"];
            this.conversationEmail = _data["conversationEmail"];
            this.conversationWhatsappNumber = _data["conversationWhatsappNumber"];
            this.location = _data["location"] ? GarageLocationDtoItem.fromJS(_data["location"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateGarageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGarageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garageLookupIdentifier"] = this.garageLookupIdentifier;
        data["website"] = this.website;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsappNumber"] = this.whatsappNumber;
        data["emailAddress"] = this.emailAddress;
        data["conversationEmail"] = this.conversationEmail;
        data["conversationWhatsappNumber"] = this.conversationWhatsappNumber;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateGarageCommand {
    garageLookupIdentifier: string;
    website?: string | undefined;
    phoneNumber: string;
    whatsappNumber?: string | undefined;
    emailAddress: string;
    conversationEmail?: string | undefined;
    conversationWhatsappNumber?: string | undefined;
    location?: GarageLocationDtoItem;
}

export class GarageLocationDtoItem implements IGarageLocationDtoItem {
    address!: string;
    city?: string;
    longitude!: number;
    latitude!: number;

    constructor(data?: IGarageLocationDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.city = _data["city"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): GarageLocationDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLocationDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export interface IGarageLocationDtoItem {
    address: string;
    city?: string;
    longitude: number;
    latitude: number;
}

export class CreateGarageServiceCommand implements ICreateGarageServiceCommand {
    type!: GarageServiceType;
    vehicleType?: VehicleType;
    title!: string;
    description!: string;
    expectedNextDateIsRequired!: boolean;
    expectedNextOdometerReadingIsRequired!: boolean;

    constructor(data?: ICreateGarageServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.vehicleType = _data["vehicleType"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expectedNextDateIsRequired = _data["expectedNextDateIsRequired"];
            this.expectedNextOdometerReadingIsRequired = _data["expectedNextOdometerReadingIsRequired"];
        }
    }

    static fromJS(data: any): CreateGarageServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGarageServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["vehicleType"] = this.vehicleType;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expectedNextDateIsRequired"] = this.expectedNextDateIsRequired;
        data["expectedNextOdometerReadingIsRequired"] = this.expectedNextOdometerReadingIsRequired;
        return data;
    }
}

export interface ICreateGarageServiceCommand {
    type: GarageServiceType;
    vehicleType?: VehicleType;
    title: string;
    description: string;
    expectedNextDateIsRequired: boolean;
    expectedNextOdometerReadingIsRequired: boolean;
}

export class UpdateGarageSettingsCommand implements IUpdateGarageSettingsCommand {
    name!: string;
    website?: string | undefined;
    phoneNumber!: string;
    whatsappNumber?: string | undefined;
    emailAddress!: string;
    conversationEmail!: string;
    conversationWhatsappNumber!: string;
    location?: GarageLocationDtoItem | undefined;

    constructor(data?: IUpdateGarageSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.website = _data["website"];
            this.phoneNumber = _data["phoneNumber"];
            this.whatsappNumber = _data["whatsappNumber"];
            this.emailAddress = _data["emailAddress"];
            this.conversationEmail = _data["conversationEmail"];
            this.conversationWhatsappNumber = _data["conversationWhatsappNumber"];
            this.location = _data["location"] ? GarageLocationDtoItem.fromJS(_data["location"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateGarageSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGarageSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["website"] = this.website;
        data["phoneNumber"] = this.phoneNumber;
        data["whatsappNumber"] = this.whatsappNumber;
        data["emailAddress"] = this.emailAddress;
        data["conversationEmail"] = this.conversationEmail;
        data["conversationWhatsappNumber"] = this.conversationWhatsappNumber;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateGarageSettingsCommand {
    name: string;
    website?: string | undefined;
    phoneNumber: string;
    whatsappNumber?: string | undefined;
    emailAddress: string;
    conversationEmail: string;
    conversationWhatsappNumber: string;
    location?: GarageLocationDtoItem | undefined;
}

export class UpdateGarageServiceCommand implements IUpdateGarageServiceCommand {
    id!: string;
    type!: GarageServiceType;
    vehicleType!: VehicleType;
    title!: string;
    description!: string;
    expectedNextDateIsRequired!: boolean;
    expectedNextOdometerReadingIsRequired!: boolean;

    constructor(data?: IUpdateGarageServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.vehicleType = _data["vehicleType"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expectedNextDateIsRequired = _data["expectedNextDateIsRequired"];
            this.expectedNextOdometerReadingIsRequired = _data["expectedNextOdometerReadingIsRequired"];
        }
    }

    static fromJS(data: any): UpdateGarageServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGarageServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["vehicleType"] = this.vehicleType;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expectedNextDateIsRequired"] = this.expectedNextDateIsRequired;
        data["expectedNextOdometerReadingIsRequired"] = this.expectedNextOdometerReadingIsRequired;
        return data;
    }
}

export interface IUpdateGarageServiceCommand {
    id: string;
    type: GarageServiceType;
    vehicleType: VehicleType;
    title: string;
    description: string;
    expectedNextDateIsRequired: boolean;
    expectedNextOdometerReadingIsRequired: boolean;
}

export class PaginatedListOfGarageLookupBriefDto implements IPaginatedListOfGarageLookupBriefDto {
    items?: GarageLookupBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfGarageLookupBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GarageLookupBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfGarageLookupBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfGarageLookupBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfGarageLookupBriefDto {
    items?: GarageLookupBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GarageLookupBriefDto implements IGarageLookupBriefDto {
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    imageThumbnail?: string | undefined;
    address?: string;
    city?: string;
    website?: string | undefined;
    daysOfWeek?: string[];
    services?: GarageServiceDtoItem[];
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    distanceInMeter?: number;

    constructor(data?: IGarageLookupBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.garageId = _data["garageId"];
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.imageThumbnail = _data["imageThumbnail"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.website = _data["website"];
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(item);
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(GarageServiceDtoItem.fromJS(item));
            }
            this.rating = _data["rating"];
            this.userRatingsTotal = _data["userRatingsTotal"];
            this.distanceInMeter = _data["distanceInMeter"];
        }
    }

    static fromJS(data: any): GarageLookupBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garageId"] = this.garageId;
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["imageThumbnail"] = this.imageThumbnail;
        data["address"] = this.address;
        data["city"] = this.city;
        data["website"] = this.website;
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item);
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        data["rating"] = this.rating;
        data["userRatingsTotal"] = this.userRatingsTotal;
        data["distanceInMeter"] = this.distanceInMeter;
        return data;
    }
}

export interface IGarageLookupBriefDto {
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    imageThumbnail?: string | undefined;
    address?: string;
    city?: string;
    website?: string | undefined;
    daysOfWeek?: string[];
    services?: GarageServiceDtoItem[];
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    distanceInMeter?: number;
}

export class GarageLookupDtoItem implements IGarageLookupDtoItem {
    id?: string;
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    image?: string;
    imageThumbnail?: string;
    daysOfWeek?: string[];
    services?: GarageServiceDtoItem[];
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    website?: string | undefined;
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    address?: string;
    city?: string;
    conversationContactEmail?: string | undefined;
    conversationContactWhatsappNumber?: string | undefined;

    constructor(data?: IGarageLookupDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.garageId = _data["garageId"];
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.imageThumbnail = _data["imageThumbnail"];
            if (Array.isArray(_data["daysOfWeek"])) {
                this.daysOfWeek = [] as any;
                for (let item of _data["daysOfWeek"])
                    this.daysOfWeek!.push(item);
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(GarageServiceDtoItem.fromJS(item));
            }
            this.phoneNumber = _data["phoneNumber"];
            this.whatsappNumber = _data["whatsappNumber"];
            this.emailAddress = _data["emailAddress"];
            this.website = _data["website"];
            this.rating = _data["rating"];
            this.userRatingsTotal = _data["userRatingsTotal"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.conversationContactEmail = _data["conversationContactEmail"];
            this.conversationContactWhatsappNumber = _data["conversationContactWhatsappNumber"];
        }
    }

    static fromJS(data: any): GarageLookupDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["garageId"] = this.garageId;
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        if (Array.isArray(this.daysOfWeek)) {
            data["daysOfWeek"] = [];
            for (let item of this.daysOfWeek)
                data["daysOfWeek"].push(item);
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        data["phoneNumber"] = this.phoneNumber;
        data["whatsappNumber"] = this.whatsappNumber;
        data["emailAddress"] = this.emailAddress;
        data["website"] = this.website;
        data["rating"] = this.rating;
        data["userRatingsTotal"] = this.userRatingsTotal;
        data["address"] = this.address;
        data["city"] = this.city;
        data["conversationContactEmail"] = this.conversationContactEmail;
        data["conversationContactWhatsappNumber"] = this.conversationContactWhatsappNumber;
        return data;
    }
}

export interface IGarageLookupDtoItem {
    id?: string;
    garageId?: string | undefined;
    identifier?: string;
    name?: string;
    image?: string;
    imageThumbnail?: string;
    daysOfWeek?: string[];
    services?: GarageServiceDtoItem[];
    phoneNumber?: string | undefined;
    whatsappNumber?: string | undefined;
    emailAddress?: string | undefined;
    website?: string | undefined;
    rating?: number | undefined;
    userRatingsTotal?: number | undefined;
    address?: string;
    city?: string;
    conversationContactEmail?: string | undefined;
    conversationContactWhatsappNumber?: string | undefined;
}

export class GarageLookupSimplefiedDto implements IGarageLookupSimplefiedDto {
    identifier?: string;
    name?: string;
    city?: string;

    constructor(data?: IGarageLookupSimplefiedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): GarageLookupSimplefiedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarageLookupSimplefiedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["city"] = this.city;
        return data;
    }
}

export interface IGarageLookupSimplefiedDto {
    identifier?: string;
    name?: string;
    city?: string;
}

export class VehicleSpecificationsCardItem implements IVehicleSpecificationsCardItem {
    licensePlate?: string;
    type?: VehicleType;
    brand?: string;
    consumption?: string;
    mileage?: string;
    dateOfMOTExpiry?: Date | undefined;
    dateOfAscription?: Date | undefined;

    constructor(data?: IVehicleSpecificationsCardItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.licensePlate = _data["licensePlate"];
            this.type = _data["type"];
            this.brand = _data["brand"];
            this.consumption = _data["consumption"];
            this.mileage = _data["mileage"];
            this.dateOfMOTExpiry = _data["dateOfMOTExpiry"] ? new Date(_data["dateOfMOTExpiry"].toString()) : <any>undefined;
            this.dateOfAscription = _data["dateOfAscription"] ? new Date(_data["dateOfAscription"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VehicleSpecificationsCardItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleSpecificationsCardItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licensePlate"] = this.licensePlate;
        data["type"] = this.type;
        data["brand"] = this.brand;
        data["consumption"] = this.consumption;
        data["mileage"] = this.mileage;
        data["dateOfMOTExpiry"] = this.dateOfMOTExpiry ? this.dateOfMOTExpiry.toISOString() : <any>undefined;
        data["dateOfAscription"] = this.dateOfAscription ? this.dateOfAscription.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVehicleSpecificationsCardItem {
    licensePlate?: string;
    type?: VehicleType;
    brand?: string;
    consumption?: string;
    mileage?: string;
    dateOfMOTExpiry?: Date | undefined;
    dateOfAscription?: Date | undefined;
}

export class VehicleSpecificationsDtoItem implements IVehicleSpecificationsDtoItem {
    data?: VehicleInfoSectionItem[];

    constructor(data?: IVehicleSpecificationsDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(VehicleInfoSectionItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleSpecificationsDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleSpecificationsDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleSpecificationsDtoItem {
    data?: VehicleInfoSectionItem[];
}

export class VehicleInfoSectionItem implements IVehicleInfoSectionItem {
    title?: string;
    values?: string[][];

    constructor(data?: IVehicleInfoSectionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): VehicleInfoSectionItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInfoSectionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IVehicleInfoSectionItem {
    title?: string;
    values?: string[][];
}

export class VehicleServiceLogDtoItem implements IVehicleServiceLogDtoItem {
    id?: string;
    garageLookupName?: string;
    garageLookupIdentifier?: string;
    type?: GarageServiceType;
    title?: string | undefined;
    description?: string | undefined;
    attachedFile?: string | undefined;
    notes?: string;
    date?: Date;
    expectedNextDate?: Date | undefined;
    odometerReading?: number;
    expectedNextOdometerReading?: number | undefined;
    status?: VehicleServiceLogStatus;
    reporterName?: string;
    reporterPhoneNumber?: string | undefined;
    reporterEmailAddress?: string | undefined;
    metaData?: string;

    constructor(data?: IVehicleServiceLogDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.garageLookupName = _data["garageLookupName"];
            this.garageLookupIdentifier = _data["garageLookupIdentifier"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.attachedFile = _data["attachedFile"];
            this.notes = _data["notes"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.expectedNextDate = _data["expectedNextDate"] ? new Date(_data["expectedNextDate"].toString()) : <any>undefined;
            this.odometerReading = _data["odometerReading"];
            this.expectedNextOdometerReading = _data["expectedNextOdometerReading"];
            this.status = _data["status"];
            this.reporterName = _data["reporterName"];
            this.reporterPhoneNumber = _data["reporterPhoneNumber"];
            this.reporterEmailAddress = _data["reporterEmailAddress"];
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): VehicleServiceLogDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleServiceLogDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["garageLookupName"] = this.garageLookupName;
        data["garageLookupIdentifier"] = this.garageLookupIdentifier;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        data["attachedFile"] = this.attachedFile;
        data["notes"] = this.notes;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["expectedNextDate"] = this.expectedNextDate ? this.expectedNextDate.toISOString() : <any>undefined;
        data["odometerReading"] = this.odometerReading;
        data["expectedNextOdometerReading"] = this.expectedNextOdometerReading;
        data["status"] = this.status;
        data["reporterName"] = this.reporterName;
        data["reporterPhoneNumber"] = this.reporterPhoneNumber;
        data["reporterEmailAddress"] = this.reporterEmailAddress;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface IVehicleServiceLogDtoItem {
    id?: string;
    garageLookupName?: string;
    garageLookupIdentifier?: string;
    type?: GarageServiceType;
    title?: string | undefined;
    description?: string | undefined;
    attachedFile?: string | undefined;
    notes?: string;
    date?: Date;
    expectedNextDate?: Date | undefined;
    odometerReading?: number;
    expectedNextOdometerReading?: number | undefined;
    status?: VehicleServiceLogStatus;
    reporterName?: string;
    reporterPhoneNumber?: string | undefined;
    reporterEmailAddress?: string | undefined;
    metaData?: string;
}

export class VehicleTimelineDtoItem implements IVehicleTimelineDtoItem {
    title?: string;
    description?: string;
    date?: Date;
    type?: VehicleTimelineType;
    extraData?: TupleOfStringAndString[];

    constructor(data?: IVehicleTimelineDtoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            if (Array.isArray(_data["extraData"])) {
                this.extraData = [] as any;
                for (let item of _data["extraData"])
                    this.extraData!.push(TupleOfStringAndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleTimelineDtoItem {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTimelineDtoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.extraData)) {
            data["extraData"] = [];
            for (let item of this.extraData)
                data["extraData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleTimelineDtoItem {
    title?: string;
    description?: string;
    date?: Date;
    type?: VehicleTimelineType;
    extraData?: TupleOfStringAndString[];
}

export enum VehicleTimelineType {
    Unknown = 0,
    Service = 1,
    Repair = 2,
    Inspection = 3,
    SucceededMOT = 400,
    FailedMOT = 401,
    OwnerChange = 402,
}

export class TupleOfStringAndString implements ITupleOfStringAndString {
    item1?: string;
    item2?: string;

    constructor(data?: ITupleOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): TupleOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface ITupleOfStringAndString {
    item1?: string;
    item2?: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}